__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1627752520366, "six": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"Utilities for writing code that runs on Python 2 and 3\"\"\"\n\nfrom __future__ import absolute_import\n\nimport functools\nimport itertools\nimport operator\nimport sys\nimport types\n\n__author__=\"Benjamin Peterson <benjamin@python.org>\"\n__version__=\"1.16.0\"\n\n\n\nPY2=sys.version_info[0]==2\nPY3=sys.version_info[0]==3\nPY34=sys.version_info[0:2]>=(3,4)\n\nif PY3:\n string_types=str,\n integer_types=int,\n class_types=type,\n text_type=str\n binary_type=bytes\n \n MAXSIZE=sys.maxsize\nelse :\n string_types=basestring,\n integer_types=(int,long)\n class_types=(type,types.ClassType)\n text_type=unicode\n binary_type=str\n \n if sys.platform.startswith(\"java\"):\n \n  MAXSIZE=int((1 <<31)-1)\n else :\n \n  class X(object):\n  \n   def __len__(self):\n    return 1 <<31\n  try :\n   len(X())\n  except OverflowError:\n  \n   MAXSIZE=int((1 <<31)-1)\n  else :\n  \n   MAXSIZE=int((1 <<63)-1)\n  del X\n  \nif PY34:\n from importlib.util import spec_from_loader\nelse :\n spec_from_loader=None\n \n \ndef _add_doc(func,doc):\n ''\n func.__doc__=doc\n \n \ndef _import_module(name):\n ''\n __import__(name)\n return sys.modules[name]\n \n \nclass _LazyDescr(object):\n\n def __init__(self,name):\n  self.name=name\n  \n def __get__(self,obj,tp):\n  result=self._resolve()\n  setattr(obj,self.name,result)\n  try :\n  \n  \n   delattr(obj.__class__,self.name)\n  except AttributeError:\n   pass\n  return result\n  \n  \nclass MovedModule(_LazyDescr):\n\n def __init__(self,name,old,new=None ):\n  super(MovedModule,self).__init__(name)\n  if PY3:\n   if new is None :\n    new=name\n   self.mod=new\n  else :\n   self.mod=old\n   \n def _resolve(self):\n  return _import_module(self.mod)\n  \n def __getattr__(self,attr):\n  _module=self._resolve()\n  value=getattr(_module,attr)\n  setattr(self,attr,value)\n  return value\n  \n  \nclass _LazyModule(types.ModuleType):\n\n def __init__(self,name):\n  super(_LazyModule,self).__init__(name)\n  self.__doc__=self.__class__.__doc__\n  \n def __dir__(self):\n  attrs=[\"__doc__\",\"__name__\"]\n  attrs +=[attr.name for attr in self._moved_attributes]\n  return attrs\n  \n  \n _moved_attributes=[]\n \n \nclass MovedAttribute(_LazyDescr):\n\n def __init__(self,name,old_mod,new_mod,old_attr=None ,new_attr=None ):\n  super(MovedAttribute,self).__init__(name)\n  if PY3:\n   if new_mod is None :\n    new_mod=name\n   self.mod=new_mod\n   if new_attr is None :\n    if old_attr is None :\n     new_attr=name\n    else :\n     new_attr=old_attr\n   self.attr=new_attr\n  else :\n   self.mod=old_mod\n   if old_attr is None :\n    old_attr=name\n   self.attr=old_attr\n   \n def _resolve(self):\n  module=_import_module(self.mod)\n  return getattr(module,self.attr)\n  \n  \nclass _SixMetaPathImporter(object):\n\n ''\n\n\n\n\n \n \n def __init__(self,six_module_name):\n  self.name=six_module_name\n  self.known_modules={}\n  \n def _add_module(self,mod,*fullnames):\n  for fullname in fullnames:\n   self.known_modules[self.name+\".\"+fullname]=mod\n   \n def _get_module(self,fullname):\n  return self.known_modules[self.name+\".\"+fullname]\n  \n def find_module(self,fullname,path=None ):\n  if fullname in self.known_modules:\n   return self\n  return None\n  \n def find_spec(self,fullname,path,target=None ):\n  if fullname in self.known_modules:\n   return spec_from_loader(fullname,self)\n  return None\n  \n def __get_module(self,fullname):\n  try :\n   return self.known_modules[fullname]\n  except KeyError:\n   raise ImportError(\"This loader does not know module \"+fullname)\n   \n def load_module(self,fullname):\n  try :\n  \n   return sys.modules[fullname]\n  except KeyError:\n   pass\n  mod=self.__get_module(fullname)\n  if isinstance(mod,MovedModule):\n   mod=mod._resolve()\n  else :\n   mod.__loader__=self\n  sys.modules[fullname]=mod\n  return mod\n  \n def is_package(self,fullname):\n  ''\n\n\n\n\n  \n  return hasattr(self.__get_module(fullname),\"__path__\")\n  \n def get_code(self,fullname):\n  ''\n\n  \n  self.__get_module(fullname)\n  return None\n get_source=get_code\n \n def create_module(self,spec):\n  return self.load_module(spec.name)\n  \n def exec_module(self,module):\n  pass\n  \n_importer=_SixMetaPathImporter(__name__)\n\n\nclass _MovedItems(_LazyModule):\n\n ''\n __path__=[]\n \n \n_moved_attributes=[\nMovedAttribute(\"cStringIO\",\"cStringIO\",\"io\",\"StringIO\"),\nMovedAttribute(\"filter\",\"itertools\",\"builtins\",\"ifilter\",\"filter\"),\nMovedAttribute(\"filterfalse\",\"itertools\",\"itertools\",\"ifilterfalse\",\"filterfalse\"),\nMovedAttribute(\"input\",\"__builtin__\",\"builtins\",\"raw_input\",\"input\"),\nMovedAttribute(\"intern\",\"__builtin__\",\"sys\"),\nMovedAttribute(\"map\",\"itertools\",\"builtins\",\"imap\",\"map\"),\nMovedAttribute(\"getcwd\",\"os\",\"os\",\"getcwdu\",\"getcwd\"),\nMovedAttribute(\"getcwdb\",\"os\",\"os\",\"getcwd\",\"getcwdb\"),\nMovedAttribute(\"getoutput\",\"commands\",\"subprocess\"),\nMovedAttribute(\"range\",\"__builtin__\",\"builtins\",\"xrange\",\"range\"),\nMovedAttribute(\"reload_module\",\"__builtin__\",\"importlib\"if PY34 else \"imp\",\"reload\"),\nMovedAttribute(\"reduce\",\"__builtin__\",\"functools\"),\nMovedAttribute(\"shlex_quote\",\"pipes\",\"shlex\",\"quote\"),\nMovedAttribute(\"StringIO\",\"StringIO\",\"io\"),\nMovedAttribute(\"UserDict\",\"UserDict\",\"collections\"),\nMovedAttribute(\"UserList\",\"UserList\",\"collections\"),\nMovedAttribute(\"UserString\",\"UserString\",\"collections\"),\nMovedAttribute(\"xrange\",\"__builtin__\",\"builtins\",\"xrange\",\"range\"),\nMovedAttribute(\"zip\",\"itertools\",\"builtins\",\"izip\",\"zip\"),\nMovedAttribute(\"zip_longest\",\"itertools\",\"itertools\",\"izip_longest\",\"zip_longest\"),\nMovedModule(\"builtins\",\"__builtin__\"),\nMovedModule(\"configparser\",\"ConfigParser\"),\nMovedModule(\"collections_abc\",\"collections\",\"collections.abc\"if sys.version_info >=(3,3)else \"collections\"),\nMovedModule(\"copyreg\",\"copy_reg\"),\nMovedModule(\"dbm_gnu\",\"gdbm\",\"dbm.gnu\"),\nMovedModule(\"dbm_ndbm\",\"dbm\",\"dbm.ndbm\"),\nMovedModule(\"_dummy_thread\",\"dummy_thread\",\"_dummy_thread\"if sys.version_info <(3,9)else \"_thread\"),\nMovedModule(\"http_cookiejar\",\"cookielib\",\"http.cookiejar\"),\nMovedModule(\"http_cookies\",\"Cookie\",\"http.cookies\"),\nMovedModule(\"html_entities\",\"htmlentitydefs\",\"html.entities\"),\nMovedModule(\"html_parser\",\"HTMLParser\",\"html.parser\"),\nMovedModule(\"http_client\",\"httplib\",\"http.client\"),\nMovedModule(\"email_mime_base\",\"email.MIMEBase\",\"email.mime.base\"),\nMovedModule(\"email_mime_image\",\"email.MIMEImage\",\"email.mime.image\"),\nMovedModule(\"email_mime_multipart\",\"email.MIMEMultipart\",\"email.mime.multipart\"),\nMovedModule(\"email_mime_nonmultipart\",\"email.MIMENonMultipart\",\"email.mime.nonmultipart\"),\nMovedModule(\"email_mime_text\",\"email.MIMEText\",\"email.mime.text\"),\nMovedModule(\"BaseHTTPServer\",\"BaseHTTPServer\",\"http.server\"),\nMovedModule(\"CGIHTTPServer\",\"CGIHTTPServer\",\"http.server\"),\nMovedModule(\"SimpleHTTPServer\",\"SimpleHTTPServer\",\"http.server\"),\nMovedModule(\"cPickle\",\"cPickle\",\"pickle\"),\nMovedModule(\"queue\",\"Queue\"),\nMovedModule(\"reprlib\",\"repr\"),\nMovedModule(\"socketserver\",\"SocketServer\"),\nMovedModule(\"_thread\",\"thread\",\"_thread\"),\nMovedModule(\"tkinter\",\"Tkinter\"),\nMovedModule(\"tkinter_dialog\",\"Dialog\",\"tkinter.dialog\"),\nMovedModule(\"tkinter_filedialog\",\"FileDialog\",\"tkinter.filedialog\"),\nMovedModule(\"tkinter_scrolledtext\",\"ScrolledText\",\"tkinter.scrolledtext\"),\nMovedModule(\"tkinter_simpledialog\",\"SimpleDialog\",\"tkinter.simpledialog\"),\nMovedModule(\"tkinter_tix\",\"Tix\",\"tkinter.tix\"),\nMovedModule(\"tkinter_ttk\",\"ttk\",\"tkinter.ttk\"),\nMovedModule(\"tkinter_constants\",\"Tkconstants\",\"tkinter.constants\"),\nMovedModule(\"tkinter_dnd\",\"Tkdnd\",\"tkinter.dnd\"),\nMovedModule(\"tkinter_colorchooser\",\"tkColorChooser\",\n\"tkinter.colorchooser\"),\nMovedModule(\"tkinter_commondialog\",\"tkCommonDialog\",\n\"tkinter.commondialog\"),\nMovedModule(\"tkinter_tkfiledialog\",\"tkFileDialog\",\"tkinter.filedialog\"),\nMovedModule(\"tkinter_font\",\"tkFont\",\"tkinter.font\"),\nMovedModule(\"tkinter_messagebox\",\"tkMessageBox\",\"tkinter.messagebox\"),\nMovedModule(\"tkinter_tksimpledialog\",\"tkSimpleDialog\",\n\"tkinter.simpledialog\"),\nMovedModule(\"urllib_parse\",__name__+\".moves.urllib_parse\",\"urllib.parse\"),\nMovedModule(\"urllib_error\",__name__+\".moves.urllib_error\",\"urllib.error\"),\nMovedModule(\"urllib\",__name__+\".moves.urllib\",__name__+\".moves.urllib\"),\nMovedModule(\"urllib_robotparser\",\"robotparser\",\"urllib.robotparser\"),\nMovedModule(\"xmlrpc_client\",\"xmlrpclib\",\"xmlrpc.client\"),\nMovedModule(\"xmlrpc_server\",\"SimpleXMLRPCServer\",\"xmlrpc.server\"),\n]\n\nif sys.platform ==\"win32\":\n _moved_attributes +=[\n MovedModule(\"winreg\",\"_winreg\"),\n ]\n \nfor attr in _moved_attributes:\n setattr(_MovedItems,attr.name,attr)\n if isinstance(attr,MovedModule):\n  _importer._add_module(attr,\"moves.\"+attr.name)\ndel attr\n\n_MovedItems._moved_attributes=_moved_attributes\n\nmoves=_MovedItems(__name__+\".moves\")\n_importer._add_module(moves,\"moves\")\n\n\nclass Module_six_moves_urllib_parse(_LazyModule):\n\n ''\n \n \n_urllib_parse_moved_attributes=[\nMovedAttribute(\"ParseResult\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"SplitResult\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"parse_qs\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"parse_qsl\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"urldefrag\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"urljoin\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"urlparse\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"urlsplit\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"urlunparse\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"urlunsplit\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"quote\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"quote_plus\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"unquote\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"unquote_plus\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"unquote_to_bytes\",\"urllib\",\"urllib.parse\",\"unquote\",\"unquote_to_bytes\"),\nMovedAttribute(\"urlencode\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"splitquery\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"splittag\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"splituser\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"splitvalue\",\"urllib\",\"urllib.parse\"),\nMovedAttribute(\"uses_fragment\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"uses_netloc\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"uses_params\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"uses_query\",\"urlparse\",\"urllib.parse\"),\nMovedAttribute(\"uses_relative\",\"urlparse\",\"urllib.parse\"),\n]\nfor attr in _urllib_parse_moved_attributes:\n setattr(Module_six_moves_urllib_parse,attr.name,attr)\ndel attr\n\nModule_six_moves_urllib_parse._moved_attributes=_urllib_parse_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_parse(__name__+\".moves.urllib_parse\"),\n\"moves.urllib_parse\",\"moves.urllib.parse\")\n\n\nclass Module_six_moves_urllib_error(_LazyModule):\n\n ''\n \n \n_urllib_error_moved_attributes=[\nMovedAttribute(\"URLError\",\"urllib2\",\"urllib.error\"),\nMovedAttribute(\"HTTPError\",\"urllib2\",\"urllib.error\"),\nMovedAttribute(\"ContentTooShortError\",\"urllib\",\"urllib.error\"),\n]\nfor attr in _urllib_error_moved_attributes:\n setattr(Module_six_moves_urllib_error,attr.name,attr)\ndel attr\n\nModule_six_moves_urllib_error._moved_attributes=_urllib_error_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_error(__name__+\".moves.urllib.error\"),\n\"moves.urllib_error\",\"moves.urllib.error\")\n\n\nclass Module_six_moves_urllib_request(_LazyModule):\n\n ''\n \n \n_urllib_request_moved_attributes=[\nMovedAttribute(\"urlopen\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"install_opener\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"build_opener\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"pathname2url\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"url2pathname\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"getproxies\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"Request\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"OpenerDirector\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPDefaultErrorHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPRedirectHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPCookieProcessor\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"ProxyHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"BaseHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPPasswordMgr\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPPasswordMgrWithDefaultRealm\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"AbstractBasicAuthHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPBasicAuthHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"ProxyBasicAuthHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"AbstractDigestAuthHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPDigestAuthHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"ProxyDigestAuthHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPSHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"FileHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"FTPHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"CacheFTPHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"UnknownHandler\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"HTTPErrorProcessor\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"urlretrieve\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"urlcleanup\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"URLopener\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"FancyURLopener\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"proxy_bypass\",\"urllib\",\"urllib.request\"),\nMovedAttribute(\"parse_http_list\",\"urllib2\",\"urllib.request\"),\nMovedAttribute(\"parse_keqv_list\",\"urllib2\",\"urllib.request\"),\n]\nfor attr in _urllib_request_moved_attributes:\n setattr(Module_six_moves_urllib_request,attr.name,attr)\ndel attr\n\nModule_six_moves_urllib_request._moved_attributes=_urllib_request_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_request(__name__+\".moves.urllib.request\"),\n\"moves.urllib_request\",\"moves.urllib.request\")\n\n\nclass Module_six_moves_urllib_response(_LazyModule):\n\n ''\n \n \n_urllib_response_moved_attributes=[\nMovedAttribute(\"addbase\",\"urllib\",\"urllib.response\"),\nMovedAttribute(\"addclosehook\",\"urllib\",\"urllib.response\"),\nMovedAttribute(\"addinfo\",\"urllib\",\"urllib.response\"),\nMovedAttribute(\"addinfourl\",\"urllib\",\"urllib.response\"),\n]\nfor attr in _urllib_response_moved_attributes:\n setattr(Module_six_moves_urllib_response,attr.name,attr)\ndel attr\n\nModule_six_moves_urllib_response._moved_attributes=_urllib_response_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_response(__name__+\".moves.urllib.response\"),\n\"moves.urllib_response\",\"moves.urllib.response\")\n\n\nclass Module_six_moves_urllib_robotparser(_LazyModule):\n\n ''\n \n \n_urllib_robotparser_moved_attributes=[\nMovedAttribute(\"RobotFileParser\",\"robotparser\",\"urllib.robotparser\"),\n]\nfor attr in _urllib_robotparser_moved_attributes:\n setattr(Module_six_moves_urllib_robotparser,attr.name,attr)\ndel attr\n\nModule_six_moves_urllib_robotparser._moved_attributes=_urllib_robotparser_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_robotparser(__name__+\".moves.urllib.robotparser\"),\n\"moves.urllib_robotparser\",\"moves.urllib.robotparser\")\n\n\nclass Module_six_moves_urllib(types.ModuleType):\n\n ''\n __path__=[]\n parse=_importer._get_module(\"moves.urllib_parse\")\n error=_importer._get_module(\"moves.urllib_error\")\n request=_importer._get_module(\"moves.urllib_request\")\n response=_importer._get_module(\"moves.urllib_response\")\n robotparser=_importer._get_module(\"moves.urllib_robotparser\")\n \n def __dir__(self):\n  return ['parse','error','request','response','robotparser']\n  \n_importer._add_module(Module_six_moves_urllib(__name__+\".moves.urllib\"),\n\"moves.urllib\")\n\n\ndef add_move(move):\n ''\n setattr(_MovedItems,move.name,move)\n \n \ndef remove_move(name):\n ''\n try :\n  delattr(_MovedItems,name)\n except AttributeError:\n  try :\n   del moves.__dict__[name]\n  except KeyError:\n   raise AttributeError(\"no such move, %r\"%(name,))\n   \n   \nif PY3:\n _meth_func=\"__func__\"\n _meth_self=\"__self__\"\n \n _func_closure=\"__closure__\"\n _func_code=\"__code__\"\n _func_defaults=\"__defaults__\"\n _func_globals=\"__globals__\"\nelse :\n _meth_func=\"im_func\"\n _meth_self=\"im_self\"\n \n _func_closure=\"func_closure\"\n _func_code=\"func_code\"\n _func_defaults=\"func_defaults\"\n _func_globals=\"func_globals\"\n \n \ntry :\n advance_iterator=next\nexcept NameError:\n def advance_iterator(it):\n  return it.next()\nnext=advance_iterator\n\n\ntry :\n callable=callable\nexcept NameError:\n def callable(obj):\n  return any(\"__call__\"in klass.__dict__ for klass in type(obj).__mro__)\n  \n  \nif PY3:\n def get_unbound_function(unbound):\n  return unbound\n  \n create_bound_method=types.MethodType\n \n def create_unbound_method(func,cls):\n  return func\n  \n Iterator=object\nelse :\n def get_unbound_function(unbound):\n  return unbound.im_func\n  \n def create_bound_method(func,obj):\n  return types.MethodType(func,obj,obj.__class__)\n  \n def create_unbound_method(func,cls):\n  return types.MethodType(func,None ,cls)\n  \n class Iterator(object):\n \n  def next(self):\n   return type(self).__next__(self)\n   \n callable=callable\n_add_doc(get_unbound_function,\n\"\"\"Get the function out of a possibly unbound function\"\"\")\n\n\nget_method_function=operator.attrgetter(_meth_func)\nget_method_self=operator.attrgetter(_meth_self)\nget_function_closure=operator.attrgetter(_func_closure)\nget_function_code=operator.attrgetter(_func_code)\nget_function_defaults=operator.attrgetter(_func_defaults)\nget_function_globals=operator.attrgetter(_func_globals)\n\n\nif PY3:\n def iterkeys(d,**kw):\n  return iter(d.keys(**kw))\n  \n def itervalues(d,**kw):\n  return iter(d.values(**kw))\n  \n def iteritems(d,**kw):\n  return iter(d.items(**kw))\n  \n def iterlists(d,**kw):\n  return iter(d.lists(**kw))\n  \n viewkeys=operator.methodcaller(\"keys\")\n \n viewvalues=operator.methodcaller(\"values\")\n \n viewitems=operator.methodcaller(\"items\")\nelse :\n def iterkeys(d,**kw):\n  return d.iterkeys(**kw)\n  \n def itervalues(d,**kw):\n  return d.itervalues(**kw)\n  \n def iteritems(d,**kw):\n  return d.iteritems(**kw)\n  \n def iterlists(d,**kw):\n  return d.iterlists(**kw)\n  \n viewkeys=operator.methodcaller(\"viewkeys\")\n \n viewvalues=operator.methodcaller(\"viewvalues\")\n \n viewitems=operator.methodcaller(\"viewitems\")\n \n_add_doc(iterkeys,\"Return an iterator over the keys of a dictionary.\")\n_add_doc(itervalues,\"Return an iterator over the values of a dictionary.\")\n_add_doc(iteritems,\n\"Return an iterator over the (key, value) pairs of a dictionary.\")\n_add_doc(iterlists,\n\"Return an iterator over the (key, [values]) pairs of a dictionary.\")\n\n\nif PY3:\n def b(s):\n  return s.encode(\"latin-1\")\n  \n def u(s):\n  return s\n unichr=chr\n import struct\n int2byte=struct.Struct(\">B\").pack\n del struct\n byte2int=operator.itemgetter(0)\n indexbytes=operator.getitem\n iterbytes=iter\n import io\n StringIO=io.StringIO\n BytesIO=io.BytesIO\n del io\n _assertCountEqual=\"assertCountEqual\"\n if sys.version_info[1]<=1:\n  _assertRaisesRegex=\"assertRaisesRegexp\"\n  _assertRegex=\"assertRegexpMatches\"\n  _assertNotRegex=\"assertNotRegexpMatches\"\n else :\n  _assertRaisesRegex=\"assertRaisesRegex\"\n  _assertRegex=\"assertRegex\"\n  _assertNotRegex=\"assertNotRegex\"\nelse :\n def b(s):\n  return s\n  \n  \n def u(s):\n  return unicode(s.replace(r'\\\\',r'\\\\\\\\'),\"unicode_escape\")\n unichr=unichr\n int2byte=chr\n \n def byte2int(bs):\n  return ord(bs[0])\n  \n def indexbytes(buf,i):\n  return ord(buf[i])\n iterbytes=functools.partial(itertools.imap,ord)\n import StringIO\n StringIO=BytesIO=StringIO.StringIO\n _assertCountEqual=\"assertItemsEqual\"\n _assertRaisesRegex=\"assertRaisesRegexp\"\n _assertRegex=\"assertRegexpMatches\"\n _assertNotRegex=\"assertNotRegexpMatches\"\n_add_doc(b,\"\"\"Byte literal\"\"\")\n_add_doc(u,\"\"\"Text literal\"\"\")\n\n\ndef assertCountEqual(self,*args,**kwargs):\n return getattr(self,_assertCountEqual)(*args,**kwargs)\n \n \ndef assertRaisesRegex(self,*args,**kwargs):\n return getattr(self,_assertRaisesRegex)(*args,**kwargs)\n \n \ndef assertRegex(self,*args,**kwargs):\n return getattr(self,_assertRegex)(*args,**kwargs)\n \n \ndef assertNotRegex(self,*args,**kwargs):\n return getattr(self,_assertNotRegex)(*args,**kwargs)\n \n \nif PY3:\n exec_=getattr(moves.builtins,\"exec\")\n \n def reraise(tp,value,tb=None ):\n  try :\n   if value is None :\n    value=tp()\n   if value.__traceback__ is not tb:\n    raise value.with_traceback(tb)\n   raise value\n  finally :\n   value=None\n   tb=None\n   \nelse :\n def exec_(_code_,_globs_=None ,_locs_=None ):\n  ''\n  if _globs_ is None :\n   frame=sys._getframe(1)\n   _globs_=frame.f_globals\n   if _locs_ is None :\n    _locs_=frame.f_locals\n   del frame\n  elif _locs_ is None :\n   _locs_=_globs_\n  exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n  \n exec_(\"\"\"def reraise(tp, value, tb=None):\n    try:\n        raise tp, value, tb\n    finally:\n        tb = None\n\"\"\")\n \n \nif sys.version_info[:2]>(3,):\n exec_(\"\"\"def raise_from(value, from_value):\n    try:\n        raise value from from_value\n    finally:\n        value = None\n\"\"\")\nelse :\n def raise_from(value,from_value):\n  raise value\n  \n  \nprint_=getattr(moves.builtins,\"print\",None )\nif print_ is None :\n def print_(*args,**kwargs):\n  ''\n  fp=kwargs.pop(\"file\",sys.stdout)\n  if fp is None :\n   return\n   \n  def write(data):\n   if not isinstance(data,basestring):\n    data=str(data)\n    \n   if (isinstance(fp,file)and\n   isinstance(data,unicode)and\n   fp.encoding is not None ):\n    errors=getattr(fp,\"errors\",None )\n    if errors is None :\n     errors=\"strict\"\n    data=data.encode(fp.encoding,errors)\n   fp.write(data)\n  want_unicode=False\n  sep=kwargs.pop(\"sep\",None )\n  if sep is not None :\n   if isinstance(sep,unicode):\n    want_unicode=True\n   elif not isinstance(sep,str):\n    raise TypeError(\"sep must be None or a string\")\n  end=kwargs.pop(\"end\",None )\n  if end is not None :\n   if isinstance(end,unicode):\n    want_unicode=True\n   elif not isinstance(end,str):\n    raise TypeError(\"end must be None or a string\")\n  if kwargs:\n   raise TypeError(\"invalid keyword arguments to print()\")\n  if not want_unicode:\n   for arg in args:\n    if isinstance(arg,unicode):\n     want_unicode=True\n     break\n  if want_unicode:\n   newline=unicode(\"\\n\")\n   space=unicode(\" \")\n  else :\n   newline=\"\\n\"\n   space=\" \"\n  if sep is None :\n   sep=space\n  if end is None :\n   end=newline\n  for i,arg in enumerate(args):\n   if i:\n    write(sep)\n   write(arg)\n  write(end)\nif sys.version_info[:2]<(3,3):\n _print=print_\n \n def print_(*args,**kwargs):\n  fp=kwargs.get(\"file\",sys.stdout)\n  flush=kwargs.pop(\"flush\",False )\n  _print(*args,**kwargs)\n  if flush and fp is not None :\n   fp.flush()\n   \n_add_doc(reraise,\"\"\"Reraise an exception.\"\"\")\n\nif sys.version_info[0:2]<(3,4):\n\n\n\n\n\n def _update_wrapper(wrapper,wrapped,\n assigned=functools.WRAPPER_ASSIGNMENTS,\n updated=functools.WRAPPER_UPDATES):\n  for attr in assigned:\n   try :\n    value=getattr(wrapped,attr)\n   except AttributeError:\n    continue\n   else :\n    setattr(wrapper,attr,value)\n  for attr in updated:\n   getattr(wrapper,attr).update(getattr(wrapped,attr,{}))\n  wrapper.__wrapped__=wrapped\n  return wrapper\n _update_wrapper.__doc__=functools.update_wrapper.__doc__\n \n def wraps(wrapped,assigned=functools.WRAPPER_ASSIGNMENTS,\n updated=functools.WRAPPER_UPDATES):\n  return functools.partial(_update_wrapper,wrapped=wrapped,\n  assigned=assigned,updated=updated)\n wraps.__doc__=functools.wraps.__doc__\n \nelse :\n wraps=functools.wraps\n \n \ndef with_metaclass(meta,*bases):\n ''\n \n \n \n class metaclass(type):\n \n  def __new__(cls,name,this_bases,d):\n   if sys.version_info[:2]>=(3,7):\n   \n   \n    resolved_bases=types.resolve_bases(bases)\n    if resolved_bases is not bases:\n     d['__orig_bases__']=bases\n   else :\n    resolved_bases=bases\n   return meta(name,resolved_bases,d)\n   \n  @classmethod\n  def __prepare__(cls,name,this_bases):\n   return meta.__prepare__(name,bases)\n return type.__new__(metaclass,'temporary_class',(),{})\n \n \ndef add_metaclass(metaclass):\n ''\n def wrapper(cls):\n  orig_vars=cls.__dict__.copy()\n  slots=orig_vars.get('__slots__')\n  if slots is not None :\n   if isinstance(slots,str):\n    slots=[slots]\n   for slots_var in slots:\n    orig_vars.pop(slots_var)\n  orig_vars.pop('__dict__',None )\n  orig_vars.pop('__weakref__',None )\n  if hasattr(cls,'__qualname__'):\n   orig_vars['__qualname__']=cls.__qualname__\n  return metaclass(cls.__name__,cls.__bases__,orig_vars)\n return wrapper\n \n \ndef ensure_binary(s,encoding='utf-8',errors='strict'):\n ''\n\n\n\n\n\n\n\n\n \n if isinstance(s,binary_type):\n  return s\n if isinstance(s,text_type):\n  return s.encode(encoding,errors)\n raise TypeError(\"not expecting type '%s'\"%type(s))\n \n \ndef ensure_str(s,encoding='utf-8',errors='strict'):\n ''\n\n\n\n\n\n\n\n\n \n \n if type(s)is str:\n  return s\n if PY2 and isinstance(s,text_type):\n  return s.encode(encoding,errors)\n elif PY3 and isinstance(s,binary_type):\n  return s.decode(encoding,errors)\n elif not isinstance(s,(text_type,binary_type)):\n  raise TypeError(\"not expecting type '%s'\"%type(s))\n return s\n \n \ndef ensure_text(s,encoding='utf-8',errors='strict'):\n ''\n\n\n\n\n\n\n\n\n \n if isinstance(s,binary_type):\n  return s.decode(encoding,errors)\n elif isinstance(s,text_type):\n  return s\n else :\n  raise TypeError(\"not expecting type '%s'\"%type(s))\n  \n  \ndef python_2_unicode_compatible(klass):\n ''\n\n\n\n\n\n \n if PY2:\n  if '__str__'not in klass.__dict__:\n   raise ValueError(\"@python_2_unicode_compatible cannot be applied \"\n   \"to %s because it doesn't define __str__().\"%\n   klass.__name__)\n  klass.__unicode__=klass.__str__\n  klass.__str__=lambda self:self.__unicode__().encode('utf-8')\n return klass\n \n \n \n \n \n__path__=[]\n__package__=__name__\nif globals().get(\"__spec__\")is not None :\n __spec__.submodule_search_locations=[]\n \n \n \nif sys.meta_path:\n for i,importer in enumerate(sys.meta_path):\n \n \n \n \n  if (type(importer).__name__ ==\"_SixMetaPathImporter\"and\n  importer.name ==__name__):\n   del sys.meta_path[i]\n   break\n del i,importer\n \nsys.meta_path.append(_importer)\n", ["StringIO", "__future__", "functools", "importlib.util", "io", "itertools", "operator", "struct", "sys", "types"]], "dateutil.utils": [".py", "\n''\n\n\n\n\n\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime,time\n\n\ndef today(tzinfo=None ):\n ''\n\n\n\n\n\n\n\n\n \n \n dt=datetime.now(tzinfo)\n return datetime.combine(dt.date(),time(0,tzinfo=tzinfo))\n \n \ndef default_tzinfo(dt,tzinfo):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if dt.tzinfo is not None :\n  return dt\n else :\n  return dt.replace(tzinfo=tzinfo)\n  \n  \ndef within_delta(dt1,dt2,delta):\n ''\n\n\n \n delta=abs(delta)\n difference=dt1 -dt2\n return -delta <=difference <=delta\n", ["__future__", "datetime"]], "dateutil.tzwin": [".py", "\nfrom .tz.win import *\n", ["dateutil.tz.win"]], "dateutil.rrule": [".py", "\n''\n\n\n\n\n\nimport calendar\nimport datetime\nimport heapq\nimport itertools\nimport re\nimport sys\nfrom functools import wraps\n\nfrom warnings import warn\n\nfrom six import advance_iterator,integer_types\n\nfrom six.moves import _thread,range\n\nfrom ._common import weekday as weekdaybase\n\ntry :\n from math import gcd\nexcept ImportError:\n from fractions import gcd\n \n__all__=[\"rrule\",\"rruleset\",\"rrulestr\",\n\"YEARLY\",\"MONTHLY\",\"WEEKLY\",\"DAILY\",\n\"HOURLY\",\"MINUTELY\",\"SECONDLY\",\n\"MO\",\"TU\",\"WE\",\"TH\",\"FR\",\"SA\",\"SU\"]\n\n\nM366MASK=tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30+\n[7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)\nM365MASK=list(M366MASK)\nM29,M30,M31=list(range(1,30)),list(range(1,31)),list(range(1,32))\nMDAY366MASK=tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])\nMDAY365MASK=list(MDAY366MASK)\nM29,M30,M31=list(range(-29,0)),list(range(-30,0)),list(range(-31,0))\nNMDAY366MASK=tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])\nNMDAY365MASK=list(NMDAY366MASK)\nM366RANGE=(0,31,60,91,121,152,182,213,244,274,305,335,366)\nM365RANGE=(0,31,59,90,120,151,181,212,243,273,304,334,365)\nWDAYMASK=[0,1,2,3,4,5,6]*55\ndel M29,M30,M31,M365MASK[59],MDAY365MASK[59],NMDAY365MASK[31]\nMDAY365MASK=tuple(MDAY365MASK)\nM365MASK=tuple(M365MASK)\n\nFREQNAMES=['YEARLY','MONTHLY','WEEKLY','DAILY','HOURLY','MINUTELY','SECONDLY']\n\n(YEARLY,\nMONTHLY,\nWEEKLY,\nDAILY,\nHOURLY,\nMINUTELY,\nSECONDLY)=list(range(7))\n\n\neaster=None\nparser=None\n\n\nclass weekday(weekdaybase):\n ''\n\n \n def __init__(self,wkday,n=None ):\n  if n ==0:\n   raise ValueError(\"Can't create weekday with n==0\")\n   \n  super(weekday,self).__init__(wkday,n)\n  \n  \nMO,TU,WE,TH,FR,SA,SU=weekdays=tuple(weekday(x)for x in range(7))\n\n\ndef _invalidates_cache(f):\n ''\n\n\n \n @wraps(f)\n def inner_func(self,*args,**kwargs):\n  rv=f(self,*args,**kwargs)\n  self._invalidate_cache()\n  return rv\n  \n return inner_func\n \n \nclass rrulebase(object):\n def __init__(self,cache=False ):\n  if cache:\n   self._cache=[]\n   self._cache_lock=_thread.allocate_lock()\n   self._invalidate_cache()\n  else :\n   self._cache=None\n   self._cache_complete=False\n   self._len=None\n   \n def __iter__(self):\n  if self._cache_complete:\n   return iter(self._cache)\n  elif self._cache is None :\n   return self._iter()\n  else :\n   return self._iter_cached()\n   \n def _invalidate_cache(self):\n  if self._cache is not None :\n   self._cache=[]\n   self._cache_complete=False\n   self._cache_gen=self._iter()\n   \n   if self._cache_lock.locked():\n    self._cache_lock.release()\n    \n  self._len=None\n  \n def _iter_cached(self):\n  i=0\n  gen=self._cache_gen\n  cache=self._cache\n  acquire=self._cache_lock.acquire\n  release=self._cache_lock.release\n  while gen:\n   if i ==len(cache):\n    acquire()\n    if self._cache_complete:\n     break\n    try :\n     for j in range(10):\n      cache.append(advance_iterator(gen))\n    except StopIteration:\n     self._cache_gen=gen=None\n     self._cache_complete=True\n     break\n    release()\n   yield cache[i]\n   i +=1\n  while i <self._len:\n   yield cache[i]\n   i +=1\n   \n def __getitem__(self,item):\n  if self._cache_complete:\n   return self._cache[item]\n  elif isinstance(item,slice):\n   if item.step and item.step <0:\n    return list(iter(self))[item]\n   else :\n    return list(itertools.islice(self,\n    item.start or 0,\n    item.stop or sys.maxsize,\n    item.step or 1))\n  elif item >=0:\n   gen=iter(self)\n   try :\n    for i in range(item+1):\n     res=advance_iterator(gen)\n   except StopIteration:\n    raise IndexError\n   return res\n  else :\n   return list(iter(self))[item]\n   \n def __contains__(self,item):\n  if self._cache_complete:\n   return item in self._cache\n  else :\n   for i in self:\n    if i ==item:\n     return True\n    elif i >item:\n     return False\n  return False\n  \n  \n def count(self):\n  ''\n  \n  if self._len is None :\n   for x in self:\n    pass\n  return self._len\n  \n def before(self,dt,inc=False ):\n  ''\n\n  \n  if self._cache_complete:\n   gen=self._cache\n  else :\n   gen=self\n  last=None\n  if inc:\n   for i in gen:\n    if i >dt:\n     break\n    last=i\n  else :\n   for i in gen:\n    if i >=dt:\n     break\n    last=i\n  return last\n  \n def after(self,dt,inc=False ):\n  ''\n\n  \n  if self._cache_complete:\n   gen=self._cache\n  else :\n   gen=self\n  if inc:\n   for i in gen:\n    if i >=dt:\n     return i\n  else :\n   for i in gen:\n    if i >dt:\n     return i\n  return None\n  \n def xafter(self,dt,count=None ,inc=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if self._cache_complete:\n   gen=self._cache\n  else :\n   gen=self\n   \n   \n  if inc:\n   comp=lambda dc,dtc:dc >=dtc\n  else :\n   comp=lambda dc,dtc:dc >dtc\n   \n   \n  n=0\n  for d in gen:\n   if comp(d,dt):\n    if count is not None :\n     n +=1\n     if n >count:\n      break\n      \n    yield d\n    \n def between(self,after,before,inc=False ,count=1):\n  ''\n\n\n  \n  if self._cache_complete:\n   gen=self._cache\n  else :\n   gen=self\n  started=False\n  l=[]\n  if inc:\n   for i in gen:\n    if i >before:\n     break\n    elif not started:\n     if i >=after:\n      started=True\n      l.append(i)\n    else :\n     l.append(i)\n  else :\n   for i in gen:\n    if i >=before:\n     break\n    elif not started:\n     if i >after:\n      started=True\n      l.append(i)\n    else :\n     l.append(i)\n  return l\n  \n  \nclass rrule(rrulebase):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,freq,dtstart=None ,\n interval=1,wkst=None ,count=None ,until=None ,bysetpos=None ,\n bymonth=None ,bymonthday=None ,byyearday=None ,byeaster=None ,\n byweekno=None ,byweekday=None ,\n byhour=None ,byminute=None ,bysecond=None ,\n cache=False ):\n  super(rrule,self).__init__(cache)\n  global easter\n  if not dtstart:\n   if until and until.tzinfo:\n    dtstart=datetime.datetime.now(tz=until.tzinfo).replace(microsecond=0)\n   else :\n    dtstart=datetime.datetime.now().replace(microsecond=0)\n  elif not isinstance(dtstart,datetime.datetime):\n   dtstart=datetime.datetime.fromordinal(dtstart.toordinal())\n  else :\n   dtstart=dtstart.replace(microsecond=0)\n  self._dtstart=dtstart\n  self._tzinfo=dtstart.tzinfo\n  self._freq=freq\n  self._interval=interval\n  self._count=count\n  \n  \n  \n  \n  \n  self._original_rule={}\n  \n  if until and not isinstance(until,datetime.datetime):\n   until=datetime.datetime.fromordinal(until.toordinal())\n  self._until=until\n  \n  if self._dtstart and self._until:\n   if (self._dtstart.tzinfo is not None )!=(self._until.tzinfo is not None ):\n   \n   \n   \n   \n   \n   \n   \n    raise ValueError(\n    'RRULE UNTIL values must be specified in UTC when DTSTART '\n    'is timezone-aware'\n    )\n    \n  if count is not None and until:\n   warn(\"Using both 'count' and 'until' is inconsistent with RFC 5545\"\n   \" and has been deprecated in dateutil. Future versions will \"\n   \"raise an error.\",DeprecationWarning)\n   \n  if wkst is None :\n   self._wkst=calendar.firstweekday()\n  elif isinstance(wkst,integer_types):\n   self._wkst=wkst\n  else :\n   self._wkst=wkst.weekday\n   \n  if bysetpos is None :\n   self._bysetpos=None\n  elif isinstance(bysetpos,integer_types):\n   if bysetpos ==0 or not (-366 <=bysetpos <=366):\n    raise ValueError(\"bysetpos must be between 1 and 366, \"\n    \"or between -366 and -1\")\n   self._bysetpos=(bysetpos,)\n  else :\n   self._bysetpos=tuple(bysetpos)\n   for pos in self._bysetpos:\n    if pos ==0 or not (-366 <=pos <=366):\n     raise ValueError(\"bysetpos must be between 1 and 366, \"\n     \"or between -366 and -1\")\n     \n  if self._bysetpos:\n   self._original_rule['bysetpos']=self._bysetpos\n   \n  if (byweekno is None and byyearday is None and bymonthday is None and\n  byweekday is None and byeaster is None ):\n   if freq ==YEARLY:\n    if bymonth is None :\n     bymonth=dtstart.month\n     self._original_rule['bymonth']=None\n    bymonthday=dtstart.day\n    self._original_rule['bymonthday']=None\n   elif freq ==MONTHLY:\n    bymonthday=dtstart.day\n    self._original_rule['bymonthday']=None\n   elif freq ==WEEKLY:\n    byweekday=dtstart.weekday()\n    self._original_rule['byweekday']=None\n    \n    \n  if bymonth is None :\n   self._bymonth=None\n  else :\n   if isinstance(bymonth,integer_types):\n    bymonth=(bymonth,)\n    \n   self._bymonth=tuple(sorted(set(bymonth)))\n   \n   if 'bymonth'not in self._original_rule:\n    self._original_rule['bymonth']=self._bymonth\n    \n    \n  if byyearday is None :\n   self._byyearday=None\n  else :\n   if isinstance(byyearday,integer_types):\n    byyearday=(byyearday,)\n    \n   self._byyearday=tuple(sorted(set(byyearday)))\n   self._original_rule['byyearday']=self._byyearday\n   \n   \n  if byeaster is not None :\n   if not easter:\n    from dateutil import easter\n   if isinstance(byeaster,integer_types):\n    self._byeaster=(byeaster,)\n   else :\n    self._byeaster=tuple(sorted(byeaster))\n    \n   self._original_rule['byeaster']=self._byeaster\n  else :\n   self._byeaster=None\n   \n   \n  if bymonthday is None :\n   self._bymonthday=()\n   self._bynmonthday=()\n  else :\n   if isinstance(bymonthday,integer_types):\n    bymonthday=(bymonthday,)\n    \n   bymonthday=set(bymonthday)\n   \n   self._bymonthday=tuple(sorted(x for x in bymonthday if x >0))\n   self._bynmonthday=tuple(sorted(x for x in bymonthday if x <0))\n   \n   \n   if 'bymonthday'not in self._original_rule:\n    self._original_rule['bymonthday']=tuple(\n    itertools.chain(self._bymonthday,self._bynmonthday))\n    \n    \n  if byweekno is None :\n   self._byweekno=None\n  else :\n   if isinstance(byweekno,integer_types):\n    byweekno=(byweekno,)\n    \n   self._byweekno=tuple(sorted(set(byweekno)))\n   \n   self._original_rule['byweekno']=self._byweekno\n   \n   \n  if byweekday is None :\n   self._byweekday=None\n   self._bynweekday=None\n  else :\n  \n  \n  \n   if isinstance(byweekday,integer_types)or hasattr(byweekday,\"n\"):\n    byweekday=(byweekday,)\n    \n   self._byweekday=set()\n   self._bynweekday=set()\n   for wday in byweekday:\n    if isinstance(wday,integer_types):\n     self._byweekday.add(wday)\n    elif not wday.n or freq >MONTHLY:\n     self._byweekday.add(wday.weekday)\n    else :\n     self._bynweekday.add((wday.weekday,wday.n))\n     \n   if not self._byweekday:\n    self._byweekday=None\n   elif not self._bynweekday:\n    self._bynweekday=None\n    \n   if self._byweekday is not None :\n    self._byweekday=tuple(sorted(self._byweekday))\n    orig_byweekday=[weekday(x)for x in self._byweekday]\n   else :\n    orig_byweekday=()\n    \n   if self._bynweekday is not None :\n    self._bynweekday=tuple(sorted(self._bynweekday))\n    orig_bynweekday=[weekday(*x)for x in self._bynweekday]\n   else :\n    orig_bynweekday=()\n    \n   if 'byweekday'not in self._original_rule:\n    self._original_rule['byweekday']=tuple(itertools.chain(\n    orig_byweekday,orig_bynweekday))\n    \n    \n  if byhour is None :\n   if freq <HOURLY:\n    self._byhour={dtstart.hour}\n   else :\n    self._byhour=None\n  else :\n   if isinstance(byhour,integer_types):\n    byhour=(byhour,)\n    \n   if freq ==HOURLY:\n    self._byhour=self.__construct_byset(start=dtstart.hour,\n    byxxx=byhour,\n    base=24)\n   else :\n    self._byhour=set(byhour)\n    \n   self._byhour=tuple(sorted(self._byhour))\n   self._original_rule['byhour']=self._byhour\n   \n   \n  if byminute is None :\n   if freq <MINUTELY:\n    self._byminute={dtstart.minute}\n   else :\n    self._byminute=None\n  else :\n   if isinstance(byminute,integer_types):\n    byminute=(byminute,)\n    \n   if freq ==MINUTELY:\n    self._byminute=self.__construct_byset(start=dtstart.minute,\n    byxxx=byminute,\n    base=60)\n   else :\n    self._byminute=set(byminute)\n    \n   self._byminute=tuple(sorted(self._byminute))\n   self._original_rule['byminute']=self._byminute\n   \n   \n  if bysecond is None :\n   if freq <SECONDLY:\n    self._bysecond=((dtstart.second,))\n   else :\n    self._bysecond=None\n  else :\n   if isinstance(bysecond,integer_types):\n    bysecond=(bysecond,)\n    \n   self._bysecond=set(bysecond)\n   \n   if freq ==SECONDLY:\n    self._bysecond=self.__construct_byset(start=dtstart.second,\n    byxxx=bysecond,\n    base=60)\n   else :\n    self._bysecond=set(bysecond)\n    \n   self._bysecond=tuple(sorted(self._bysecond))\n   self._original_rule['bysecond']=self._bysecond\n   \n  if self._freq >=HOURLY:\n   self._timeset=None\n  else :\n   self._timeset=[]\n   for hour in self._byhour:\n    for minute in self._byminute:\n     for second in self._bysecond:\n      self._timeset.append(\n      datetime.time(hour,minute,second,\n      tzinfo=self._tzinfo))\n   self._timeset.sort()\n   self._timeset=tuple(self._timeset)\n   \n def __str__(self):\n  ''\n\n\n\n  \n  \n  output=[]\n  h,m,s=[None ]*3\n  if self._dtstart:\n   output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))\n   h,m,s=self._dtstart.timetuple()[3:6]\n   \n  parts=['FREQ='+FREQNAMES[self._freq]]\n  if self._interval !=1:\n   parts.append('INTERVAL='+str(self._interval))\n   \n  if self._wkst:\n   parts.append('WKST='+repr(weekday(self._wkst))[0:2])\n   \n  if self._count is not None :\n   parts.append('COUNT='+str(self._count))\n   \n  if self._until:\n   parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))\n   \n  if self._original_rule.get('byweekday')is not None :\n  \n  \n   original_rule=dict(self._original_rule)\n   wday_strings=[]\n   for wday in original_rule['byweekday']:\n    if wday.n:\n     wday_strings.append('{n:+d}{wday}'.format(\n     n=wday.n,\n     wday=repr(wday)[0:2]))\n    else :\n     wday_strings.append(repr(wday))\n     \n   original_rule['byweekday']=wday_strings\n  else :\n   original_rule=self._original_rule\n   \n  partfmt='{name}={vals}'\n  for name,key in [('BYSETPOS','bysetpos'),\n  ('BYMONTH','bymonth'),\n  ('BYMONTHDAY','bymonthday'),\n  ('BYYEARDAY','byyearday'),\n  ('BYWEEKNO','byweekno'),\n  ('BYDAY','byweekday'),\n  ('BYHOUR','byhour'),\n  ('BYMINUTE','byminute'),\n  ('BYSECOND','bysecond'),\n  ('BYEASTER','byeaster')]:\n   value=original_rule.get(key)\n   if value:\n    parts.append(partfmt.format(name=name,vals=(','.join(str(v)\n    for v in value))))\n    \n  output.append('RRULE:'+';'.join(parts))\n  return '\\n'.join(output)\n  \n def replace(self,**kwargs):\n  ''\n  \n  new_kwargs={\"interval\":self._interval,\n  \"count\":self._count,\n  \"dtstart\":self._dtstart,\n  \"freq\":self._freq,\n  \"until\":self._until,\n  \"wkst\":self._wkst,\n  \"cache\":False if self._cache is None else True }\n  new_kwargs.update(self._original_rule)\n  new_kwargs.update(kwargs)\n  return rrule(**new_kwargs)\n  \n def _iter(self):\n  year,month,day,hour,minute,second,weekday,yearday,_=\\\n  self._dtstart.timetuple()\n  \n  \n  freq=self._freq\n  interval=self._interval\n  wkst=self._wkst\n  until=self._until\n  bymonth=self._bymonth\n  byweekno=self._byweekno\n  byyearday=self._byyearday\n  byweekday=self._byweekday\n  byeaster=self._byeaster\n  bymonthday=self._bymonthday\n  bynmonthday=self._bynmonthday\n  bysetpos=self._bysetpos\n  byhour=self._byhour\n  byminute=self._byminute\n  bysecond=self._bysecond\n  \n  ii=_iterinfo(self)\n  ii.rebuild(year,month)\n  \n  getdayset={YEARLY:ii.ydayset,\n  MONTHLY:ii.mdayset,\n  WEEKLY:ii.wdayset,\n  DAILY:ii.ddayset,\n  HOURLY:ii.ddayset,\n  MINUTELY:ii.ddayset,\n  SECONDLY:ii.ddayset}[freq]\n  \n  if freq <HOURLY:\n   timeset=self._timeset\n  else :\n   gettimeset={HOURLY:ii.htimeset,\n   MINUTELY:ii.mtimeset,\n   SECONDLY:ii.stimeset}[freq]\n   if ((freq >=HOURLY and\n   self._byhour and hour not in self._byhour)or\n   (freq >=MINUTELY and\n   self._byminute and minute not in self._byminute)or\n   (freq >=SECONDLY and\n   self._bysecond and second not in self._bysecond)):\n    timeset=()\n   else :\n    timeset=gettimeset(hour,minute,second)\n    \n  total=0\n  count=self._count\n  while True :\n  \n   dayset,start,end=getdayset(year,month,day)\n   \n   \n   filtered=False\n   for i in dayset[start:end]:\n    if ((bymonth and ii.mmask[i]not in bymonth)or\n    (byweekno and not ii.wnomask[i])or\n    (byweekday and ii.wdaymask[i]not in byweekday)or\n    (ii.nwdaymask and not ii.nwdaymask[i])or\n    (byeaster and not ii.eastermask[i])or\n    ((bymonthday or bynmonthday)and\n    ii.mdaymask[i]not in bymonthday and\n    ii.nmdaymask[i]not in bynmonthday)or\n    (byyearday and\n    ((i <ii.yearlen and i+1 not in byyearday and\n    -ii.yearlen+i not in byyearday)or\n    (i >=ii.yearlen and i+1 -ii.yearlen not in byyearday and\n    -ii.nextyearlen+i -ii.yearlen not in byyearday)))):\n     dayset[i]=None\n     filtered=True\n     \n     \n   if bysetpos and timeset:\n    poslist=[]\n    for pos in bysetpos:\n     if pos <0:\n      daypos,timepos=divmod(pos,len(timeset))\n     else :\n      daypos,timepos=divmod(pos -1,len(timeset))\n     try :\n      i=[x for x in dayset[start:end]\n      if x is not None ][daypos]\n      time=timeset[timepos]\n     except IndexError:\n      pass\n     else :\n      date=datetime.date.fromordinal(ii.yearordinal+i)\n      res=datetime.datetime.combine(date,time)\n      if res not in poslist:\n       poslist.append(res)\n    poslist.sort()\n    for res in poslist:\n     if until and res >until:\n      self._len=total\n      return\n     elif res >=self._dtstart:\n      if count is not None :\n       count -=1\n       if count <0:\n        self._len=total\n        return\n      total +=1\n      yield res\n   else :\n    for i in dayset[start:end]:\n     if i is not None :\n      date=datetime.date.fromordinal(ii.yearordinal+i)\n      for time in timeset:\n       res=datetime.datetime.combine(date,time)\n       if until and res >until:\n        self._len=total\n        return\n       elif res >=self._dtstart:\n        if count is not None :\n         count -=1\n         if count <0:\n          self._len=total\n          return\n          \n        total +=1\n        yield res\n        \n        \n   fixday=False\n   if freq ==YEARLY:\n    year +=interval\n    if year >datetime.MAXYEAR:\n     self._len=total\n     return\n    ii.rebuild(year,month)\n   elif freq ==MONTHLY:\n    month +=interval\n    if month >12:\n     div,mod=divmod(month,12)\n     month=mod\n     year +=div\n     if month ==0:\n      month=12\n      year -=1\n     if year >datetime.MAXYEAR:\n      self._len=total\n      return\n    ii.rebuild(year,month)\n   elif freq ==WEEKLY:\n    if wkst >weekday:\n     day +=-(weekday+1+(6 -wkst))+self._interval *7\n    else :\n     day +=-(weekday -wkst)+self._interval *7\n    weekday=wkst\n    fixday=True\n   elif freq ==DAILY:\n    day +=interval\n    fixday=True\n   elif freq ==HOURLY:\n    if filtered:\n    \n     hour +=((23 -hour)//interval)*interval\n     \n    if byhour:\n     ndays,hour=self.__mod_distance(value=hour,\n     byxxx=self._byhour,\n     base=24)\n    else :\n     ndays,hour=divmod(hour+interval,24)\n     \n    if ndays:\n     day +=ndays\n     fixday=True\n     \n    timeset=gettimeset(hour,minute,second)\n   elif freq ==MINUTELY:\n    if filtered:\n    \n     minute +=((1439 -(hour *60+minute))//interval)*interval\n     \n    valid=False\n    rep_rate=(24 *60)\n    for j in range(rep_rate //gcd(interval,rep_rate)):\n     if byminute:\n      nhours,minute=\\\n      self.__mod_distance(value=minute,\n      byxxx=self._byminute,\n      base=60)\n     else :\n      nhours,minute=divmod(minute+interval,60)\n      \n     div,hour=divmod(hour+nhours,24)\n     if div:\n      day +=div\n      fixday=True\n      filtered=False\n      \n     if not byhour or hour in byhour:\n      valid=True\n      break\n      \n    if not valid:\n     raise ValueError('Invalid combination of interval and '+\n     'byhour resulting in empty rule.')\n     \n    timeset=gettimeset(hour,minute,second)\n   elif freq ==SECONDLY:\n    if filtered:\n    \n     second +=(((86399 -(hour *3600+minute *60+second))\n     //interval)*interval)\n     \n    rep_rate=(24 *3600)\n    valid=False\n    for j in range(0,rep_rate //gcd(interval,rep_rate)):\n     if bysecond:\n      nminutes,second=\\\n      self.__mod_distance(value=second,\n      byxxx=self._bysecond,\n      base=60)\n     else :\n      nminutes,second=divmod(second+interval,60)\n      \n     div,minute=divmod(minute+nminutes,60)\n     if div:\n      hour +=div\n      div,hour=divmod(hour,24)\n      if div:\n       day +=div\n       fixday=True\n       \n     if ((not byhour or hour in byhour)and\n     (not byminute or minute in byminute)and\n     (not bysecond or second in bysecond)):\n      valid=True\n      break\n      \n    if not valid:\n     raise ValueError('Invalid combination of interval, '+\n     'byhour and byminute resulting in empty'+\n     ' rule.')\n     \n    timeset=gettimeset(hour,minute,second)\n    \n   if fixday and day >28:\n    daysinmonth=calendar.monthrange(year,month)[1]\n    if day >daysinmonth:\n     while day >daysinmonth:\n      day -=daysinmonth\n      month +=1\n      if month ==13:\n       month=1\n       year +=1\n       if year >datetime.MAXYEAR:\n        self._len=total\n        return\n      daysinmonth=calendar.monthrange(year,month)[1]\n     ii.rebuild(year,month)\n     \n def __construct_byset(self,start,byxxx,base):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  cset=set()\n  \n  \n  if isinstance(byxxx,integer_types):\n   byxxx=(byxxx,)\n   \n  for num in byxxx:\n   i_gcd=gcd(self._interval,base)\n   \n   if i_gcd ==1 or divmod(num -start,i_gcd)[1]==0:\n    cset.add(num)\n    \n  if len(cset)==0:\n   raise ValueError(\"Invalid rrule byxxx generates an empty set.\")\n   \n  return cset\n  \n def __mod_distance(self,value,byxxx,base):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  accumulator=0\n  for ii in range(1,base+1):\n  \n   div,value=divmod(value+self._interval,base)\n   accumulator +=div\n   if value in byxxx:\n    return (accumulator,value)\n    \n    \nclass _iterinfo(object):\n __slots__=[\"rrule\",\"lastyear\",\"lastmonth\",\n \"yearlen\",\"nextyearlen\",\"yearordinal\",\"yearweekday\",\n \"mmask\",\"mrange\",\"mdaymask\",\"nmdaymask\",\n \"wdaymask\",\"wnomask\",\"nwdaymask\",\"eastermask\"]\n \n def __init__(self,rrule):\n  for attr in self.__slots__:\n   setattr(self,attr,None )\n  self.rrule=rrule\n  \n def rebuild(self,year,month):\n \n  rr=self.rrule\n  if year !=self.lastyear:\n   self.yearlen=365+calendar.isleap(year)\n   self.nextyearlen=365+calendar.isleap(year+1)\n   firstyday=datetime.date(year,1,1)\n   self.yearordinal=firstyday.toordinal()\n   self.yearweekday=firstyday.weekday()\n   \n   wday=datetime.date(year,1,1).weekday()\n   if self.yearlen ==365:\n    self.mmask=M365MASK\n    self.mdaymask=MDAY365MASK\n    self.nmdaymask=NMDAY365MASK\n    self.wdaymask=WDAYMASK[wday:]\n    self.mrange=M365RANGE\n   else :\n    self.mmask=M366MASK\n    self.mdaymask=MDAY366MASK\n    self.nmdaymask=NMDAY366MASK\n    self.wdaymask=WDAYMASK[wday:]\n    self.mrange=M366RANGE\n    \n   if not rr._byweekno:\n    self.wnomask=None\n   else :\n    self.wnomask=[0]*(self.yearlen+7)\n    \n    no1wkst=firstwkst=(7 -self.yearweekday+rr._wkst)%7\n    if no1wkst >=4:\n     no1wkst=0\n     \n     \n     wyearlen=self.yearlen+(self.yearweekday -rr._wkst)%7\n    else :\n    \n    \n     wyearlen=self.yearlen -no1wkst\n    div,mod=divmod(wyearlen,7)\n    numweeks=div+mod //4\n    for n in rr._byweekno:\n     if n <0:\n      n +=numweeks+1\n     if not (0 <n <=numweeks):\n      continue\n     if n >1:\n      i=no1wkst+(n -1)*7\n      if no1wkst !=firstwkst:\n       i -=7 -firstwkst\n     else :\n      i=no1wkst\n     for j in range(7):\n      self.wnomask[i]=1\n      i +=1\n      if self.wdaymask[i]==rr._wkst:\n       break\n    if 1 in rr._byweekno:\n    \n    \n     i=no1wkst+numweeks *7\n     if no1wkst !=firstwkst:\n      i -=7 -firstwkst\n     if i <self.yearlen:\n     \n     \n      for j in range(7):\n       self.wnomask[i]=1\n       i +=1\n       if self.wdaymask[i]==rr._wkst:\n        break\n    if no1wkst:\n    \n    \n    \n    \n    \n    \n     if -1 not in rr._byweekno:\n      lyearweekday=datetime.date(year -1,1,1).weekday()\n      lno1wkst=(7 -lyearweekday+rr._wkst)%7\n      lyearlen=365+calendar.isleap(year -1)\n      if lno1wkst >=4:\n       lno1wkst=0\n       lnumweeks=52+(lyearlen+\n       (lyearweekday -rr._wkst)%7)%7 //4\n      else :\n       lnumweeks=52+(self.yearlen -no1wkst)%7 //4\n     else :\n      lnumweeks=-1\n     if lnumweeks in rr._byweekno:\n      for i in range(no1wkst):\n       self.wnomask[i]=1\n       \n  if (rr._bynweekday and (month !=self.lastmonth or\n  year !=self.lastyear)):\n   ranges=[]\n   if rr._freq ==YEARLY:\n    if rr._bymonth:\n     for month in rr._bymonth:\n      ranges.append(self.mrange[month -1:month+1])\n    else :\n     ranges=[(0,self.yearlen)]\n   elif rr._freq ==MONTHLY:\n    ranges=[self.mrange[month -1:month+1]]\n   if ranges:\n   \n   \n    self.nwdaymask=[0]*self.yearlen\n    for first,last in ranges:\n     last -=1\n     for wday,n in rr._bynweekday:\n      if n <0:\n       i=last+(n+1)*7\n       i -=(self.wdaymask[i]-wday)%7\n      else :\n       i=first+(n -1)*7\n       i +=(7 -self.wdaymask[i]+wday)%7\n      if first <=i <=last:\n       self.nwdaymask[i]=1\n       \n  if rr._byeaster:\n   self.eastermask=[0]*(self.yearlen+7)\n   eyday=easter.easter(year).toordinal()-self.yearordinal\n   for offset in rr._byeaster:\n    self.eastermask[eyday+offset]=1\n    \n  self.lastyear=year\n  self.lastmonth=month\n  \n def ydayset(self,year,month,day):\n  return list(range(self.yearlen)),0,self.yearlen\n  \n def mdayset(self,year,month,day):\n  dset=[None ]*self.yearlen\n  start,end=self.mrange[month -1:month+1]\n  for i in range(start,end):\n   dset[i]=i\n  return dset,start,end\n  \n def wdayset(self,year,month,day):\n \n  dset=[None ]*(self.yearlen+7)\n  i=datetime.date(year,month,day).toordinal()-self.yearordinal\n  start=i\n  for j in range(7):\n   dset[i]=i\n   i +=1\n   \n   \n   \n   if self.wdaymask[i]==self.rrule._wkst:\n    break\n  return dset,start,i\n  \n def ddayset(self,year,month,day):\n  dset=[None ]*self.yearlen\n  i=datetime.date(year,month,day).toordinal()-self.yearordinal\n  dset[i]=i\n  return dset,i,i+1\n  \n def htimeset(self,hour,minute,second):\n  tset=[]\n  rr=self.rrule\n  for minute in rr._byminute:\n   for second in rr._bysecond:\n    tset.append(datetime.time(hour,minute,second,\n    tzinfo=rr._tzinfo))\n  tset.sort()\n  return tset\n  \n def mtimeset(self,hour,minute,second):\n  tset=[]\n  rr=self.rrule\n  for second in rr._bysecond:\n   tset.append(datetime.time(hour,minute,second,tzinfo=rr._tzinfo))\n  tset.sort()\n  return tset\n  \n def stimeset(self,hour,minute,second):\n  return (datetime.time(hour,minute,second,\n  tzinfo=self.rrule._tzinfo),)\n  \n  \nclass rruleset(rrulebase):\n ''\n\n\n\n\n \n \n class _genitem(object):\n  def __init__(self,genlist,gen):\n   try :\n    self.dt=advance_iterator(gen)\n    genlist.append(self)\n   except StopIteration:\n    pass\n   self.genlist=genlist\n   self.gen=gen\n   \n  def __next__(self):\n   try :\n    self.dt=advance_iterator(self.gen)\n   except StopIteration:\n    if self.genlist[0]is self:\n     heapq.heappop(self.genlist)\n    else :\n     self.genlist.remove(self)\n     heapq.heapify(self.genlist)\n     \n  next=__next__\n  \n  def __lt__(self,other):\n   return self.dt <other.dt\n   \n  def __gt__(self,other):\n   return self.dt >other.dt\n   \n  def __eq__(self,other):\n   return self.dt ==other.dt\n   \n  def __ne__(self,other):\n   return self.dt !=other.dt\n   \n def __init__(self,cache=False ):\n  super(rruleset,self).__init__(cache)\n  self._rrule=[]\n  self._rdate=[]\n  self._exrule=[]\n  self._exdate=[]\n  \n @_invalidates_cache\n def rrule(self,rrule):\n  ''\n  \n  self._rrule.append(rrule)\n  \n @_invalidates_cache\n def rdate(self,rdate):\n  ''\n  \n  self._rdate.append(rdate)\n  \n @_invalidates_cache\n def exrule(self,exrule):\n  ''\n\n\n  \n  self._exrule.append(exrule)\n  \n @_invalidates_cache\n def exdate(self,exdate):\n  ''\n\n  \n  self._exdate.append(exdate)\n  \n def _iter(self):\n  rlist=[]\n  self._rdate.sort()\n  self._genitem(rlist,iter(self._rdate))\n  for gen in [iter(x)for x in self._rrule]:\n   self._genitem(rlist,gen)\n  exlist=[]\n  self._exdate.sort()\n  self._genitem(exlist,iter(self._exdate))\n  for gen in [iter(x)for x in self._exrule]:\n   self._genitem(exlist,gen)\n  lastdt=None\n  total=0\n  heapq.heapify(rlist)\n  heapq.heapify(exlist)\n  while rlist:\n   ritem=rlist[0]\n   if not lastdt or lastdt !=ritem.dt:\n    while exlist and exlist[0]<ritem:\n     exitem=exlist[0]\n     advance_iterator(exitem)\n     if exlist and exlist[0]is exitem:\n      heapq.heapreplace(exlist,exitem)\n    if not exlist or ritem !=exlist[0]:\n     total +=1\n     yield ritem.dt\n    lastdt=ritem.dt\n   advance_iterator(ritem)\n   if rlist and rlist[0]is ritem:\n    heapq.heapreplace(rlist,ritem)\n  self._len=total\n  \n  \n  \n  \nclass _rrulestr(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _freq_map={\"YEARLY\":YEARLY,\n \"MONTHLY\":MONTHLY,\n \"WEEKLY\":WEEKLY,\n \"DAILY\":DAILY,\n \"HOURLY\":HOURLY,\n \"MINUTELY\":MINUTELY,\n \"SECONDLY\":SECONDLY}\n \n _weekday_map={\"MO\":0,\"TU\":1,\"WE\":2,\"TH\":3,\n \"FR\":4,\"SA\":5,\"SU\":6}\n \n def _handle_int(self,rrkwargs,name,value,**kwargs):\n  rrkwargs[name.lower()]=int(value)\n  \n def _handle_int_list(self,rrkwargs,name,value,**kwargs):\n  rrkwargs[name.lower()]=[int(x)for x in value.split(',')]\n  \n _handle_INTERVAL=_handle_int\n _handle_COUNT=_handle_int\n _handle_BYSETPOS=_handle_int_list\n _handle_BYMONTH=_handle_int_list\n _handle_BYMONTHDAY=_handle_int_list\n _handle_BYYEARDAY=_handle_int_list\n _handle_BYEASTER=_handle_int_list\n _handle_BYWEEKNO=_handle_int_list\n _handle_BYHOUR=_handle_int_list\n _handle_BYMINUTE=_handle_int_list\n _handle_BYSECOND=_handle_int_list\n \n def _handle_FREQ(self,rrkwargs,name,value,**kwargs):\n  rrkwargs[\"freq\"]=self._freq_map[value]\n  \n def _handle_UNTIL(self,rrkwargs,name,value,**kwargs):\n  global parser\n  if not parser:\n   from dateutil import parser\n  try :\n   rrkwargs[\"until\"]=parser.parse(value,\n   ignoretz=kwargs.get(\"ignoretz\"),\n   tzinfos=kwargs.get(\"tzinfos\"))\n  except ValueError:\n   raise ValueError(\"invalid until date\")\n   \n def _handle_WKST(self,rrkwargs,name,value,**kwargs):\n  rrkwargs[\"wkst\"]=self._weekday_map[value]\n  \n def _handle_BYWEEKDAY(self,rrkwargs,name,value,**kwargs):\n  ''\n\n  \n  l=[]\n  for wday in value.split(','):\n   if '('in wday:\n   \n    splt=wday.split('(')\n    w=splt[0]\n    n=int(splt[1][:-1])\n   elif len(wday):\n   \n    for i in range(len(wday)):\n     if wday[i]not in '+-0123456789':\n      break\n    n=wday[:i]or None\n    w=wday[i:]\n    if n:\n     n=int(n)\n   else :\n    raise ValueError(\"Invalid (empty) BYDAY specification.\")\n    \n   l.append(weekdays[self._weekday_map[w]](n))\n  rrkwargs[\"byweekday\"]=l\n  \n _handle_BYDAY=_handle_BYWEEKDAY\n \n def _parse_rfc_rrule(self,line,\n dtstart=None ,\n cache=False ,\n ignoretz=False ,\n tzinfos=None ):\n  if line.find(':')!=-1:\n   name,value=line.split(':')\n   if name !=\"RRULE\":\n    raise ValueError(\"unknown parameter name\")\n  else :\n   value=line\n  rrkwargs={}\n  for pair in value.split(';'):\n   name,value=pair.split('=')\n   name=name.upper()\n   value=value.upper()\n   try :\n    getattr(self,\"_handle_\"+name)(rrkwargs,name,value,\n    ignoretz=ignoretz,\n    tzinfos=tzinfos)\n   except AttributeError:\n    raise ValueError(\"unknown parameter '%s'\"%name)\n   except (KeyError,ValueError):\n    raise ValueError(\"invalid '%s': %s\"%(name,value))\n  return rrule(dtstart=dtstart,cache=cache,**rrkwargs)\n  \n def _parse_date_value(self,date_value,parms,rule_tzids,\n ignoretz,tzids,tzinfos):\n  global parser\n  if not parser:\n   from dateutil import parser\n   \n  datevals=[]\n  value_found=False\n  TZID=None\n  \n  for parm in parms:\n   if parm.startswith(\"TZID=\"):\n    try :\n     tzkey=rule_tzids[parm.split('TZID=')[-1]]\n    except KeyError:\n     continue\n    if tzids is None :\n     from . import tz\n     tzlookup=tz.gettz\n    elif callable(tzids):\n     tzlookup=tzids\n    else :\n     tzlookup=getattr(tzids,'get',None )\n     if tzlookup is None :\n      msg=('tzids must be a callable, mapping, or None, '\n      'not %s'%tzids)\n      raise ValueError(msg)\n      \n    TZID=tzlookup(tzkey)\n    continue\n    \n    \n    \n   if parm not in {\"VALUE=DATE-TIME\",\"VALUE=DATE\"}:\n    raise ValueError(\"unsupported parm: \"+parm)\n   else :\n    if value_found:\n     msg=(\"Duplicate value parameter found in: \"+parm)\n     raise ValueError(msg)\n    value_found=True\n    \n  for datestr in date_value.split(','):\n   date=parser.parse(datestr,ignoretz=ignoretz,tzinfos=tzinfos)\n   if TZID is not None :\n    if date.tzinfo is None :\n     date=date.replace(tzinfo=TZID)\n    else :\n     raise ValueError('DTSTART/EXDATE specifies multiple timezone')\n   datevals.append(date)\n   \n  return datevals\n  \n def _parse_rfc(self,s,\n dtstart=None ,\n cache=False ,\n unfold=False ,\n forceset=False ,\n compatible=False ,\n ignoretz=False ,\n tzids=None ,\n tzinfos=None ):\n  global parser\n  if compatible:\n   forceset=True\n   unfold=True\n   \n  TZID_NAMES=dict(map(\n  lambda x:(x.upper(),x),\n  re.findall('TZID=(?P<name>[^:]+):',s)\n  ))\n  s=s.upper()\n  if not s.strip():\n   raise ValueError(\"empty string\")\n  if unfold:\n   lines=s.splitlines()\n   i=0\n   while i <len(lines):\n    line=lines[i].rstrip()\n    if not line:\n     del lines[i]\n    elif i >0 and line[0]==\" \":\n     lines[i -1]+=line[1:]\n     del lines[i]\n    else :\n     i +=1\n  else :\n   lines=s.split()\n  if (not forceset and len(lines)==1 and (s.find(':')==-1 or\n  s.startswith('RRULE:'))):\n   return self._parse_rfc_rrule(lines[0],cache=cache,\n   dtstart=dtstart,ignoretz=ignoretz,\n   tzinfos=tzinfos)\n  else :\n   rrulevals=[]\n   rdatevals=[]\n   exrulevals=[]\n   exdatevals=[]\n   for line in lines:\n    if not line:\n     continue\n    if line.find(':')==-1:\n     name=\"RRULE\"\n     value=line\n    else :\n     name,value=line.split(':',1)\n    parms=name.split(';')\n    if not parms:\n     raise ValueError(\"empty property name\")\n    name=parms[0]\n    parms=parms[1:]\n    if name ==\"RRULE\":\n     for parm in parms:\n      raise ValueError(\"unsupported RRULE parm: \"+parm)\n     rrulevals.append(value)\n    elif name ==\"RDATE\":\n     for parm in parms:\n      if parm !=\"VALUE=DATE-TIME\":\n       raise ValueError(\"unsupported RDATE parm: \"+parm)\n     rdatevals.append(value)\n    elif name ==\"EXRULE\":\n     for parm in parms:\n      raise ValueError(\"unsupported EXRULE parm: \"+parm)\n     exrulevals.append(value)\n    elif name ==\"EXDATE\":\n     exdatevals.extend(\n     self._parse_date_value(value,parms,\n     TZID_NAMES,ignoretz,\n     tzids,tzinfos)\n     )\n    elif name ==\"DTSTART\":\n     dtvals=self._parse_date_value(value,parms,TZID_NAMES,\n     ignoretz,tzids,tzinfos)\n     if len(dtvals)!=1:\n      raise ValueError(\"Multiple DTSTART values specified:\"+\n      value)\n     dtstart=dtvals[0]\n    else :\n     raise ValueError(\"unsupported property: \"+name)\n   if (forceset or len(rrulevals)>1 or rdatevals\n   or exrulevals or exdatevals):\n    if not parser and (rdatevals or exdatevals):\n     from dateutil import parser\n    rset=rruleset(cache=cache)\n    for value in rrulevals:\n     rset.rrule(self._parse_rfc_rrule(value,dtstart=dtstart,\n     ignoretz=ignoretz,\n     tzinfos=tzinfos))\n    for value in rdatevals:\n     for datestr in value.split(','):\n      rset.rdate(parser.parse(datestr,\n      ignoretz=ignoretz,\n      tzinfos=tzinfos))\n    for value in exrulevals:\n     rset.exrule(self._parse_rfc_rrule(value,dtstart=dtstart,\n     ignoretz=ignoretz,\n     tzinfos=tzinfos))\n    for value in exdatevals:\n     rset.exdate(value)\n    if compatible and dtstart:\n     rset.rdate(dtstart)\n    return rset\n   else :\n    return self._parse_rfc_rrule(rrulevals[0],\n    dtstart=dtstart,\n    cache=cache,\n    ignoretz=ignoretz,\n    tzinfos=tzinfos)\n    \n def __call__(self,s,**kwargs):\n  return self._parse_rfc(s,**kwargs)\n  \n  \nrrulestr=_rrulestr()\n\n\n", ["calendar", "datetime", "dateutil", "dateutil._common", "dateutil.easter", "fractions", "functools", "heapq", "itertools", "math", "re", "six", "six.moves", "sys", "warnings"]], "dateutil.relativedelta": [".py", "\nimport datetime\nimport calendar\n\nimport operator\nfrom math import copysign\n\nfrom six import integer_types\nfrom warnings import warn\n\nfrom ._common import weekday\n\nMO,TU,WE,TH,FR,SA,SU=weekdays=tuple(weekday(x)for x in range(7))\n\n__all__=[\"relativedelta\",\"MO\",\"TU\",\"WE\",\"TH\",\"FR\",\"SA\",\"SU\"]\n\n\nclass relativedelta(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,dt1=None ,dt2=None ,\n years=0,months=0,days=0,leapdays=0,weeks=0,\n hours=0,minutes=0,seconds=0,microseconds=0,\n year=None ,month=None ,day=None ,weekday=None ,\n yearday=None ,nlyearday=None ,\n hour=None ,minute=None ,second=None ,microsecond=None ):\n \n  if dt1 and dt2:\n  \n   if not (isinstance(dt1,datetime.date)and\n   isinstance(dt2,datetime.date)):\n    raise TypeError(\"relativedelta only diffs datetime/date\")\n    \n    \n    \n   if (isinstance(dt1,datetime.datetime)!=\n   isinstance(dt2,datetime.datetime)):\n    if not isinstance(dt1,datetime.datetime):\n     dt1=datetime.datetime.fromordinal(dt1.toordinal())\n    elif not isinstance(dt2,datetime.datetime):\n     dt2=datetime.datetime.fromordinal(dt2.toordinal())\n     \n   self.years=0\n   self.months=0\n   self.days=0\n   self.leapdays=0\n   self.hours=0\n   self.minutes=0\n   self.seconds=0\n   self.microseconds=0\n   self.year=None\n   self.month=None\n   self.day=None\n   self.weekday=None\n   self.hour=None\n   self.minute=None\n   self.second=None\n   self.microsecond=None\n   self._has_time=0\n   \n   \n   months=(dt1.year -dt2.year)*12+(dt1.month -dt2.month)\n   self._set_months(months)\n   \n   \n   \n   dtm=self.__radd__(dt2)\n   \n   \n   if dt1 <dt2:\n    compare=operator.gt\n    increment=1\n   else :\n    compare=operator.lt\n    increment=-1\n    \n   while compare(dt1,dtm):\n    months +=increment\n    self._set_months(months)\n    dtm=self.__radd__(dt2)\n    \n    \n   delta=dt1 -dtm\n   self.seconds=delta.seconds+delta.days *86400\n   self.microseconds=delta.microseconds\n  else :\n  \n   if any(x is not None and x !=int(x)for x in (years,months)):\n    raise ValueError(\"Non-integer years and months are \"\n    \"ambiguous and not currently supported.\")\n    \n    \n   self.years=int(years)\n   self.months=int(months)\n   self.days=days+weeks *7\n   self.leapdays=leapdays\n   self.hours=hours\n   self.minutes=minutes\n   self.seconds=seconds\n   self.microseconds=microseconds\n   \n   \n   self.year=year\n   self.month=month\n   self.day=day\n   self.hour=hour\n   self.minute=minute\n   self.second=second\n   self.microsecond=microsecond\n   \n   if any(x is not None and int(x)!=x\n   for x in (year,month,day,hour,\n   minute,second,microsecond)):\n   \n    warn(\"Non-integer value passed as absolute information. \"+\n    \"This is not a well-defined condition and will raise \"+\n    \"errors in future versions.\",DeprecationWarning)\n    \n   if isinstance(weekday,integer_types):\n    self.weekday=weekdays[weekday]\n   else :\n    self.weekday=weekday\n    \n   yday=0\n   if nlyearday:\n    yday=nlyearday\n   elif yearday:\n    yday=yearday\n    if yearday >59:\n     self.leapdays=-1\n   if yday:\n    ydayidx=[31,59,90,120,151,181,212,\n    243,273,304,334,366]\n    for idx,ydays in enumerate(ydayidx):\n     if yday <=ydays:\n      self.month=idx+1\n      if idx ==0:\n       self.day=yday\n      else :\n       self.day=yday -ydayidx[idx -1]\n      break\n    else :\n     raise ValueError(\"invalid year day (%d)\"%yday)\n     \n  self._fix()\n  \n def _fix(self):\n  if abs(self.microseconds)>999999:\n   s=_sign(self.microseconds)\n   div,mod=divmod(self.microseconds *s,1000000)\n   self.microseconds=mod *s\n   self.seconds +=div *s\n  if abs(self.seconds)>59:\n   s=_sign(self.seconds)\n   div,mod=divmod(self.seconds *s,60)\n   self.seconds=mod *s\n   self.minutes +=div *s\n  if abs(self.minutes)>59:\n   s=_sign(self.minutes)\n   div,mod=divmod(self.minutes *s,60)\n   self.minutes=mod *s\n   self.hours +=div *s\n  if abs(self.hours)>23:\n   s=_sign(self.hours)\n   div,mod=divmod(self.hours *s,24)\n   self.hours=mod *s\n   self.days +=div *s\n  if abs(self.months)>11:\n   s=_sign(self.months)\n   div,mod=divmod(self.months *s,12)\n   self.months=mod *s\n   self.years +=div *s\n  if (self.hours or self.minutes or self.seconds or self.microseconds\n  or self.hour is not None or self.minute is not None or\n  self.second is not None or self.microsecond is not None ):\n   self._has_time=1\n  else :\n   self._has_time=0\n   \n @property\n def weeks(self):\n  return int(self.days /7.0)\n  \n @weeks.setter\n def weeks(self,value):\n  self.days=self.days -(self.weeks *7)+value *7\n  \n def _set_months(self,months):\n  self.months=months\n  if abs(self.months)>11:\n   s=_sign(self.months)\n   div,mod=divmod(self.months *s,12)\n   self.months=mod *s\n   self.years=div *s\n  else :\n   self.years=0\n   \n def normalized(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  days=int(self.days)\n  \n  hours_f=round(self.hours+24 *(self.days -days),11)\n  hours=int(hours_f)\n  \n  minutes_f=round(self.minutes+60 *(hours_f -hours),10)\n  minutes=int(minutes_f)\n  \n  seconds_f=round(self.seconds+60 *(minutes_f -minutes),8)\n  seconds=int(seconds_f)\n  \n  microseconds=round(self.microseconds+1e6 *(seconds_f -seconds))\n  \n  \n  return self.__class__(years=self.years,months=self.months,\n  days=days,hours=hours,minutes=minutes,\n  seconds=seconds,microseconds=microseconds,\n  leapdays=self.leapdays,year=self.year,\n  month=self.month,day=self.day,\n  weekday=self.weekday,hour=self.hour,\n  minute=self.minute,second=self.second,\n  microsecond=self.microsecond)\n  \n def __add__(self,other):\n  if isinstance(other,relativedelta):\n   return self.__class__(years=other.years+self.years,\n   months=other.months+self.months,\n   days=other.days+self.days,\n   hours=other.hours+self.hours,\n   minutes=other.minutes+self.minutes,\n   seconds=other.seconds+self.seconds,\n   microseconds=(other.microseconds+\n   self.microseconds),\n   leapdays=other.leapdays or self.leapdays,\n   year=(other.year if other.year is not None\n   else self.year),\n   month=(other.month if other.month is not None\n   else self.month),\n   day=(other.day if other.day is not None\n   else self.day),\n   weekday=(other.weekday if other.weekday is not None\n   else self.weekday),\n   hour=(other.hour if other.hour is not None\n   else self.hour),\n   minute=(other.minute if other.minute is not None\n   else self.minute),\n   second=(other.second if other.second is not None\n   else self.second),\n   microsecond=(other.microsecond if other.microsecond\n   is not None else\n   self.microsecond))\n  if isinstance(other,datetime.timedelta):\n   return self.__class__(years=self.years,\n   months=self.months,\n   days=self.days+other.days,\n   hours=self.hours,\n   minutes=self.minutes,\n   seconds=self.seconds+other.seconds,\n   microseconds=self.microseconds+other.microseconds,\n   leapdays=self.leapdays,\n   year=self.year,\n   month=self.month,\n   day=self.day,\n   weekday=self.weekday,\n   hour=self.hour,\n   minute=self.minute,\n   second=self.second,\n   microsecond=self.microsecond)\n  if not isinstance(other,datetime.date):\n   return NotImplemented\n  elif self._has_time and not isinstance(other,datetime.datetime):\n   other=datetime.datetime.fromordinal(other.toordinal())\n  year=(self.year or other.year)+self.years\n  month=self.month or other.month\n  if self.months:\n   assert 1 <=abs(self.months)<=12\n   month +=self.months\n   if month >12:\n    year +=1\n    month -=12\n   elif month <1:\n    year -=1\n    month +=12\n  day=min(calendar.monthrange(year,month)[1],\n  self.day or other.day)\n  repl={\"year\":year,\"month\":month,\"day\":day}\n  for attr in [\"hour\",\"minute\",\"second\",\"microsecond\"]:\n   value=getattr(self,attr)\n   if value is not None :\n    repl[attr]=value\n  days=self.days\n  if self.leapdays and month >2 and calendar.isleap(year):\n   days +=self.leapdays\n  ret=(other.replace(**repl)\n  +datetime.timedelta(days=days,\n  hours=self.hours,\n  minutes=self.minutes,\n  seconds=self.seconds,\n  microseconds=self.microseconds))\n  if self.weekday:\n   weekday,nth=self.weekday.weekday,self.weekday.n or 1\n   jumpdays=(abs(nth)-1)*7\n   if nth >0:\n    jumpdays +=(7 -ret.weekday()+weekday)%7\n   else :\n    jumpdays +=(ret.weekday()-weekday)%7\n    jumpdays *=-1\n   ret +=datetime.timedelta(days=jumpdays)\n  return ret\n  \n def __radd__(self,other):\n  return self.__add__(other)\n  \n def __rsub__(self,other):\n  return self.__neg__().__radd__(other)\n  \n def __sub__(self,other):\n  if not isinstance(other,relativedelta):\n   return NotImplemented\n  return self.__class__(years=self.years -other.years,\n  months=self.months -other.months,\n  days=self.days -other.days,\n  hours=self.hours -other.hours,\n  minutes=self.minutes -other.minutes,\n  seconds=self.seconds -other.seconds,\n  microseconds=self.microseconds -other.microseconds,\n  leapdays=self.leapdays or other.leapdays,\n  year=(self.year if self.year is not None\n  else other.year),\n  month=(self.month if self.month is not None else\n  other.month),\n  day=(self.day if self.day is not None else\n  other.day),\n  weekday=(self.weekday if self.weekday is not None else\n  other.weekday),\n  hour=(self.hour if self.hour is not None else\n  other.hour),\n  minute=(self.minute if self.minute is not None else\n  other.minute),\n  second=(self.second if self.second is not None else\n  other.second),\n  microsecond=(self.microsecond if self.microsecond\n  is not None else\n  other.microsecond))\n  \n def __abs__(self):\n  return self.__class__(years=abs(self.years),\n  months=abs(self.months),\n  days=abs(self.days),\n  hours=abs(self.hours),\n  minutes=abs(self.minutes),\n  seconds=abs(self.seconds),\n  microseconds=abs(self.microseconds),\n  leapdays=self.leapdays,\n  year=self.year,\n  month=self.month,\n  day=self.day,\n  weekday=self.weekday,\n  hour=self.hour,\n  minute=self.minute,\n  second=self.second,\n  microsecond=self.microsecond)\n  \n def __neg__(self):\n  return self.__class__(years=-self.years,\n  months=-self.months,\n  days=-self.days,\n  hours=-self.hours,\n  minutes=-self.minutes,\n  seconds=-self.seconds,\n  microseconds=-self.microseconds,\n  leapdays=self.leapdays,\n  year=self.year,\n  month=self.month,\n  day=self.day,\n  weekday=self.weekday,\n  hour=self.hour,\n  minute=self.minute,\n  second=self.second,\n  microsecond=self.microsecond)\n  \n def __bool__(self):\n  return not (not self.years and\n  not self.months and\n  not self.days and\n  not self.hours and\n  not self.minutes and\n  not self.seconds and\n  not self.microseconds and\n  not self.leapdays and\n  self.year is None and\n  self.month is None and\n  self.day is None and\n  self.weekday is None and\n  self.hour is None and\n  self.minute is None and\n  self.second is None and\n  self.microsecond is None )\n  \n __nonzero__=__bool__\n \n def __mul__(self,other):\n  try :\n   f=float(other)\n  except TypeError:\n   return NotImplemented\n   \n  return self.__class__(years=int(self.years *f),\n  months=int(self.months *f),\n  days=int(self.days *f),\n  hours=int(self.hours *f),\n  minutes=int(self.minutes *f),\n  seconds=int(self.seconds *f),\n  microseconds=int(self.microseconds *f),\n  leapdays=self.leapdays,\n  year=self.year,\n  month=self.month,\n  day=self.day,\n  weekday=self.weekday,\n  hour=self.hour,\n  minute=self.minute,\n  second=self.second,\n  microsecond=self.microsecond)\n  \n __rmul__=__mul__\n \n def __eq__(self,other):\n  if not isinstance(other,relativedelta):\n   return NotImplemented\n  if self.weekday or other.weekday:\n   if not self.weekday or not other.weekday:\n    return False\n   if self.weekday.weekday !=other.weekday.weekday:\n    return False\n   n1,n2=self.weekday.n,other.weekday.n\n   if n1 !=n2 and not ((not n1 or n1 ==1)and (not n2 or n2 ==1)):\n    return False\n  return (self.years ==other.years and\n  self.months ==other.months and\n  self.days ==other.days and\n  self.hours ==other.hours and\n  self.minutes ==other.minutes and\n  self.seconds ==other.seconds and\n  self.microseconds ==other.microseconds and\n  self.leapdays ==other.leapdays and\n  self.year ==other.year and\n  self.month ==other.month and\n  self.day ==other.day and\n  self.hour ==other.hour and\n  self.minute ==other.minute and\n  self.second ==other.second and\n  self.microsecond ==other.microsecond)\n  \n def __hash__(self):\n  return hash((\n  self.weekday,\n  self.years,\n  self.months,\n  self.days,\n  self.hours,\n  self.minutes,\n  self.seconds,\n  self.microseconds,\n  self.leapdays,\n  self.year,\n  self.month,\n  self.day,\n  self.hour,\n  self.minute,\n  self.second,\n  self.microsecond,\n  ))\n  \n def __ne__(self,other):\n  return not self.__eq__(other)\n  \n def __div__(self,other):\n  try :\n   reciprocal=1 /float(other)\n  except TypeError:\n   return NotImplemented\n   \n  return self.__mul__(reciprocal)\n  \n __truediv__=__div__\n \n def __repr__(self):\n  l=[]\n  for attr in [\"years\",\"months\",\"days\",\"leapdays\",\n  \"hours\",\"minutes\",\"seconds\",\"microseconds\"]:\n   value=getattr(self,attr)\n   if value:\n    l.append(\"{attr}={value:+g}\".format(attr=attr,value=value))\n  for attr in [\"year\",\"month\",\"day\",\"weekday\",\n  \"hour\",\"minute\",\"second\",\"microsecond\"]:\n   value=getattr(self,attr)\n   if value is not None :\n    l.append(\"{attr}={value}\".format(attr=attr,value=repr(value)))\n  return \"{classname}({attrs})\".format(classname=self.__class__.__name__,\n  attrs=\", \".join(l))\n  \n  \ndef _sign(x):\n return int(copysign(1,x))\n \n \n", ["calendar", "datetime", "dateutil._common", "math", "operator", "six", "warnings"]], "dateutil.easter": [".py", "\n''\n\n\n\n\nimport datetime\n\n__all__=[\"easter\",\"EASTER_JULIAN\",\"EASTER_ORTHODOX\",\"EASTER_WESTERN\"]\n\nEASTER_JULIAN=1\nEASTER_ORTHODOX=2\nEASTER_WESTERN=3\n\n\ndef easter(year,method=EASTER_WESTERN):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not (1 <=method <=3):\n  raise ValueError(\"invalid method\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n y=year\n g=y %19\n e=0\n if method <3:\n \n  i=(19 *g+15)%30\n  j=(y+y //4+i)%7\n  if method ==2:\n  \n   e=10\n   if y >1600:\n    e=e+y //100 -16 -(y //100 -16)//4\n else :\n \n  c=y //100\n  h=(c -c //4 -(8 *c+13)//25+19 *g+15)%30\n  i=h -(h //28)*(1 -(h //28)*(29 //(h+1))*((21 -g)//11))\n  j=(y+y //4+i+2 -c+c //4)%7\n  \n  \n  \n p=i -j+e\n d=1+(p+27+(p+6)//40)%31\n m=3+(p+26)//30\n return datetime.date(int(y),int(m),int(d))\n", ["datetime"]], "dateutil._version": [".py", "\n\n\nversion='2.8.2'\nversion_tuple=(2,8,2)\n", []], "dateutil._common": [".py", "''\n\n\n\n\nclass weekday(object):\n __slots__=[\"weekday\",\"n\"]\n \n def __init__(self,weekday,n=None ):\n  self.weekday=weekday\n  self.n=n\n  \n def __call__(self,n):\n  if n ==self.n:\n   return self\n  else :\n   return self.__class__(self.weekday,n)\n   \n def __eq__(self,other):\n  try :\n   if self.weekday !=other.weekday or self.n !=other.n:\n    return False\n  except AttributeError:\n   return False\n  return True\n  \n def __hash__(self):\n  return hash((\n  self.weekday,\n  self.n,\n  ))\n  \n def __ne__(self,other):\n  return not (self ==other)\n  \n def __repr__(self):\n  s=(\"MO\",\"TU\",\"WE\",\"TH\",\"FR\",\"SA\",\"SU\")[self.weekday]\n  if not self.n:\n   return s\n  else :\n   return \"%s(%+d)\"%(s,self.n)\n   \n   \n", []], "dateutil": [".py", "\ntry :\n from ._version import version as __version__\nexcept ImportError:\n __version__='unknown'\n \n__all__=['easter','parser','relativedelta','rrule','tz',\n'utils','zoneinfo']\n", ["dateutil._version"], 1], "dateutil.zoneinfo.rebuild": [".py", "import logging\nimport os\nimport tempfile\nimport shutil\nimport json\nfrom subprocess import check_call,check_output\nfrom tarfile import TarFile\n\nfrom dateutil.zoneinfo import METADATA_FN,ZONEFILENAME\n\n\ndef rebuild(filename,tag=None ,format=\"gz\",zonegroups=[],metadata=None ):\n ''\n\n\n\n \n tmpdir=tempfile.mkdtemp()\n zonedir=os.path.join(tmpdir,\"zoneinfo\")\n moduledir=os.path.dirname(__file__)\n try :\n  with TarFile.open(filename)as tf:\n   for name in zonegroups:\n    tf.extract(name,tmpdir)\n   filepaths=[os.path.join(tmpdir,n)for n in zonegroups]\n   \n   _run_zic(zonedir,filepaths)\n   \n   \n  with open(os.path.join(zonedir,METADATA_FN),'w')as f:\n   json.dump(metadata,f,indent=4,sort_keys=True )\n  target=os.path.join(moduledir,ZONEFILENAME)\n  with TarFile.open(target,\"w:%s\"%format)as tf:\n   for entry in os.listdir(zonedir):\n    entrypath=os.path.join(zonedir,entry)\n    tf.add(entrypath,entry)\n finally :\n  shutil.rmtree(tmpdir)\n  \n  \ndef _run_zic(zonedir,filepaths):\n ''\n\n\n\n\n\n\n \n \n try :\n  help_text=check_output([\"zic\",\"--help\"])\n except OSError as e:\n  _print_on_nosuchfile(e)\n  raise\n  \n if b\"-b \"in help_text:\n  bloat_args=[\"-b\",\"fat\"]\n else :\n  bloat_args=[]\n  \n check_call([\"zic\"]+bloat_args+[\"-d\",zonedir]+filepaths)\n \n \ndef _print_on_nosuchfile(e):\n ''\n\n\n\n \n if e.errno ==2:\n  logging.error(\n  \"Could not find zic. Perhaps you need to install \"\n  \"libc-bin or some other package that provides it, \"\n  \"or it's not in your PATH?\")\n", ["dateutil.zoneinfo", "json", "logging", "os", "shutil", "subprocess", "tarfile", "tempfile"]], "dateutil.zoneinfo": [".py", "\nimport warnings\nimport json\n\nfrom tarfile import TarFile\nfrom pkgutil import get_data\nfrom io import BytesIO\n\nfrom dateutil.tz import tzfile as _tzfile\n\n__all__=[\"get_zonefile_instance\",\"gettz\",\"gettz_db_metadata\"]\n\nZONEFILENAME=\"dateutil-zoneinfo.tar.gz\"\nMETADATA_FN='METADATA'\n\n\nclass tzfile(_tzfile):\n def __reduce__(self):\n  return (gettz,(self._filename,))\n  \n  \ndef getzoneinfofile_stream():\n try :\n  return BytesIO(get_data(__name__,ZONEFILENAME))\n except IOError as e:\n  warnings.warn(\"I/O error({0}): {1}\".format(e.errno,e.strerror))\n  return None\n  \n  \nclass ZoneInfoFile(object):\n def __init__(self,zonefile_stream=None ):\n  if zonefile_stream is not None :\n   with TarFile.open(fileobj=zonefile_stream)as tf:\n    self.zones={zf.name:tzfile(tf.extractfile(zf),filename=zf.name)\n    for zf in tf.getmembers()\n    if zf.isfile()and zf.name !=METADATA_FN}\n    \n    \n    links={zl.name:self.zones[zl.linkname]\n    for zl in tf.getmembers()if\n    zl.islnk()or zl.issym()}\n    self.zones.update(links)\n    try :\n     metadata_json=tf.extractfile(tf.getmember(METADATA_FN))\n     metadata_str=metadata_json.read().decode('UTF-8')\n     self.metadata=json.loads(metadata_str)\n    except KeyError:\n    \n     self.metadata=None\n  else :\n   self.zones={}\n   self.metadata=None\n   \n def get(self,name,default=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  return self.zones.get(name,default)\n  \n  \n  \n  \n  \n  \n  \n  \n_CLASS_ZONE_INSTANCE=[]\n\n\ndef get_zonefile_instance(new_instance=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if new_instance:\n  zif=None\n else :\n  zif=getattr(get_zonefile_instance,'_cached_instance',None )\n  \n if zif is None :\n  zif=ZoneInfoFile(getzoneinfofile_stream())\n  \n  get_zonefile_instance._cached_instance=zif\n  \n return zif\n \n \ndef gettz(name):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n warnings.warn(\"zoneinfo.gettz() will be removed in future versions, \"\n \"to use the dateutil-provided zoneinfo files, instantiate a \"\n \"ZoneInfoFile object and use ZoneInfoFile.zones.get() \"\n \"instead. See the documentation for details.\",\n DeprecationWarning)\n \n if len(_CLASS_ZONE_INSTANCE)==0:\n  _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))\n return _CLASS_ZONE_INSTANCE[0].zones.get(name)\n \n \ndef gettz_db_metadata():\n ''\n\n\n\n\n\n\n\n\n\n \n warnings.warn(\"zoneinfo.gettz_db_metadata() will be removed in future \"\n \"versions, to use the dateutil-provided zoneinfo files, \"\n \"ZoneInfoFile object and query the 'metadata' attribute \"\n \"instead. See the documentation for details.\",\n DeprecationWarning)\n \n if len(_CLASS_ZONE_INSTANCE)==0:\n  _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))\n return _CLASS_ZONE_INSTANCE[0].metadata\n", ["dateutil.tz", "io", "json", "pkgutil", "tarfile", "warnings"], 1], "dateutil.tz.win": [".py", "\n''\n\n\n\n\n\n\n\nimport datetime\nimport struct\n\nfrom six.moves import winreg\nfrom six import text_type\n\ntry :\n import ctypes\n from ctypes import wintypes\nexcept ValueError:\n\n raise ImportError(\"Running tzwin on non-Windows system\")\n \nfrom ._common import tzrangebase\n\n__all__=[\"tzwin\",\"tzwinlocal\",\"tzres\"]\n\nONEWEEK=datetime.timedelta(7)\n\nTZKEYNAMENT=r\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\"\nTZKEYNAME9X=r\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Time Zones\"\nTZLOCALKEYNAME=r\"SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\"\n\n\ndef _settzkeyname():\n handle=winreg.ConnectRegistry(None ,winreg.HKEY_LOCAL_MACHINE)\n try :\n  winreg.OpenKey(handle,TZKEYNAMENT).Close()\n  TZKEYNAME=TZKEYNAMENT\n except WindowsError:\n  TZKEYNAME=TZKEYNAME9X\n handle.Close()\n return TZKEYNAME\n \n \nTZKEYNAME=_settzkeyname()\n\n\nclass tzres(object):\n ''\n\n\n\n\n \n p_wchar=ctypes.POINTER(wintypes.WCHAR)\n \n def __init__(self,tzres_loc='tzres.dll'):\n \n  user32=ctypes.WinDLL('user32')\n  \n  \n  user32.LoadStringW.argtypes=(wintypes.HINSTANCE,\n  wintypes.UINT,\n  wintypes.LPWSTR,\n  ctypes.c_int)\n  \n  self.LoadStringW=user32.LoadStringW\n  self._tzres=ctypes.WinDLL(tzres_loc)\n  self.tzres_loc=tzres_loc\n  \n def load_name(self,offset):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  resource=self.p_wchar()\n  lpBuffer=ctypes.cast(ctypes.byref(resource),wintypes.LPWSTR)\n  nchar=self.LoadStringW(self._tzres._handle,offset,lpBuffer,0)\n  return resource[:nchar]\n  \n def name_from_string(self,tzname_str):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not tzname_str.startswith('@'):\n   return tzname_str\n   \n  name_splt=tzname_str.split(',-')\n  try :\n   offset=int(name_splt[1])\n  except :\n   raise ValueError(\"Malformed timezone string.\")\n   \n  return self.load_name(offset)\n  \n  \nclass tzwinbase(tzrangebase):\n ''\n def __init__(self):\n  raise NotImplementedError('tzwinbase is an abstract base class')\n  \n def __eq__(self,other):\n \n  if not isinstance(other,tzwinbase):\n   return NotImplemented\n   \n  return (self._std_offset ==other._std_offset and\n  self._dst_offset ==other._dst_offset and\n  self._stddayofweek ==other._stddayofweek and\n  self._dstdayofweek ==other._dstdayofweek and\n  self._stdweeknumber ==other._stdweeknumber and\n  self._dstweeknumber ==other._dstweeknumber and\n  self._stdhour ==other._stdhour and\n  self._dsthour ==other._dsthour and\n  self._stdminute ==other._stdminute and\n  self._dstminute ==other._dstminute and\n  self._std_abbr ==other._std_abbr and\n  self._dst_abbr ==other._dst_abbr)\n  \n @staticmethod\n def list():\n  ''\n  with winreg.ConnectRegistry(None ,winreg.HKEY_LOCAL_MACHINE)as handle:\n   with winreg.OpenKey(handle,TZKEYNAME)as tzkey:\n    result=[winreg.EnumKey(tzkey,i)\n    for i in range(winreg.QueryInfoKey(tzkey)[0])]\n  return result\n  \n def display(self):\n  ''\n\n  \n  return self._display\n  \n def transitions(self,year):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if not self.hasdst:\n   return None\n   \n  dston=picknthweekday(year,self._dstmonth,self._dstdayofweek,\n  self._dsthour,self._dstminute,\n  self._dstweeknumber)\n  \n  dstoff=picknthweekday(year,self._stdmonth,self._stddayofweek,\n  self._stdhour,self._stdminute,\n  self._stdweeknumber)\n  \n  \n  dstoff -=self._dst_base_offset\n  \n  return dston,dstoff\n  \n def _get_hasdst(self):\n  return self._dstmonth !=0\n  \n @property\n def _dst_base_offset(self):\n  return self._dst_base_offset_\n  \n  \nclass tzwin(tzwinbase):\n ''\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,name):\n  self._name=name\n  \n  with winreg.ConnectRegistry(None ,winreg.HKEY_LOCAL_MACHINE)as handle:\n   tzkeyname=text_type(\"{kn}\\\\{name}\").format(kn=TZKEYNAME,name=name)\n   with winreg.OpenKey(handle,tzkeyname)as tzkey:\n    keydict=valuestodict(tzkey)\n    \n  self._std_abbr=keydict[\"Std\"]\n  self._dst_abbr=keydict[\"Dlt\"]\n  \n  self._display=keydict[\"Display\"]\n  \n  \n  tup=struct.unpack(\"=3l16h\",keydict[\"TZI\"])\n  stdoffset=-tup[0]-tup[1]\n  dstoffset=stdoffset -tup[2]\n  self._std_offset=datetime.timedelta(minutes=stdoffset)\n  self._dst_offset=datetime.timedelta(minutes=dstoffset)\n  \n  \n  \n  (self._stdmonth,\n  self._stddayofweek,\n  self._stdweeknumber,\n  self._stdhour,\n  self._stdminute)=tup[4:9]\n  \n  (self._dstmonth,\n  self._dstdayofweek,\n  self._dstweeknumber,\n  self._dsthour,\n  self._dstminute)=tup[12:17]\n  \n  self._dst_base_offset_=self._dst_offset -self._std_offset\n  self.hasdst=self._get_hasdst()\n  \n def __repr__(self):\n  return \"tzwin(%s)\"%repr(self._name)\n  \n def __reduce__(self):\n  return (self.__class__,(self._name,))\n  \n  \nclass tzwinlocal(tzwinbase):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self):\n  with winreg.ConnectRegistry(None ,winreg.HKEY_LOCAL_MACHINE)as handle:\n   with winreg.OpenKey(handle,TZLOCALKEYNAME)as tzlocalkey:\n    keydict=valuestodict(tzlocalkey)\n    \n   self._std_abbr=keydict[\"StandardName\"]\n   self._dst_abbr=keydict[\"DaylightName\"]\n   \n   try :\n    tzkeyname=text_type('{kn}\\\\{sn}').format(kn=TZKEYNAME,\n    sn=self._std_abbr)\n    with winreg.OpenKey(handle,tzkeyname)as tzkey:\n     _keydict=valuestodict(tzkey)\n     self._display=_keydict[\"Display\"]\n   except OSError:\n    self._display=None\n    \n  stdoffset=-keydict[\"Bias\"]-keydict[\"StandardBias\"]\n  dstoffset=stdoffset -keydict[\"DaylightBias\"]\n  \n  self._std_offset=datetime.timedelta(minutes=stdoffset)\n  self._dst_offset=datetime.timedelta(minutes=dstoffset)\n  \n  \n  \n  tup=struct.unpack(\"=8h\",keydict[\"StandardStart\"])\n  \n  (self._stdmonth,\n  self._stdweeknumber,\n  self._stdhour,\n  self._stdminute)=tup[1:5]\n  \n  self._stddayofweek=tup[7]\n  \n  tup=struct.unpack(\"=8h\",keydict[\"DaylightStart\"])\n  \n  (self._dstmonth,\n  self._dstweeknumber,\n  self._dsthour,\n  self._dstminute)=tup[1:5]\n  \n  self._dstdayofweek=tup[7]\n  \n  self._dst_base_offset_=self._dst_offset -self._std_offset\n  self.hasdst=self._get_hasdst()\n  \n def __repr__(self):\n  return \"tzwinlocal()\"\n  \n def __str__(self):\n \n  return \"tzwinlocal(%s)\"%repr(self._std_abbr)\n  \n def __reduce__(self):\n  return (self.__class__,())\n  \n  \ndef picknthweekday(year,month,dayofweek,hour,minute,whichweek):\n ''\n first=datetime.datetime(year,month,1,hour,minute)\n \n \n \n weekdayone=first.replace(day=((dayofweek -first.isoweekday())%7)+1)\n wd=weekdayone+((whichweek -1)*ONEWEEK)\n if (wd.month !=month):\n  wd -=ONEWEEK\n  \n return wd\n \n \ndef valuestodict(key):\n ''\n dout={}\n size=winreg.QueryInfoKey(key)[1]\n tz_res=None\n \n for i in range(size):\n  key_name,value,dtype=winreg.EnumValue(key,i)\n  if dtype ==winreg.REG_DWORD or dtype ==winreg.REG_DWORD_LITTLE_ENDIAN:\n  \n  \n   if value&(1 <<31):\n    value=value -(1 <<32)\n  elif dtype ==winreg.REG_SZ:\n  \n   if value.startswith('@tzres'):\n    tz_res=tz_res or tzres()\n    value=tz_res.name_from_string(value)\n    \n   value=value.rstrip('\\x00')\n   \n  dout[key_name]=value\n  \n return dout\n", ["ctypes", "datetime", "dateutil.tz._common", "six", "six.moves", "struct"]], "dateutil.tz.tz": [".py", "\n''\n\n\n\n\n\n\n\nimport datetime\nimport struct\nimport time\nimport sys\nimport os\nimport bisect\nimport weakref\nfrom collections import OrderedDict\n\nimport six\nfrom six import string_types\nfrom six.moves import _thread\nfrom ._common import tzname_in_python2,_tzinfo\nfrom ._common import tzrangebase,enfold\nfrom ._common import _validate_fromutc_inputs\n\nfrom ._factories import _TzSingleton,_TzOffsetFactory\nfrom ._factories import _TzStrFactory\ntry :\n from .win import tzwin,tzwinlocal\nexcept ImportError:\n tzwin=tzwinlocal=None\n \n \nfrom warnings import warn\n\nZERO=datetime.timedelta(0)\nEPOCH=datetime.datetime.utcfromtimestamp(0)\nEPOCHORDINAL=EPOCH.toordinal()\n\n\n@six.add_metaclass(_TzSingleton)\nclass tzutc(datetime.tzinfo):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def utcoffset(self,dt):\n  return ZERO\n  \n def dst(self,dt):\n  return ZERO\n  \n @tzname_in_python2\n def tzname(self,dt):\n  return \"UTC\"\n  \n def is_ambiguous(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  return False\n  \n @_validate_fromutc_inputs\n def fromutc(self,dt):\n  ''\n\n\n  \n  return dt\n  \n def __eq__(self,other):\n  if not isinstance(other,(tzutc,tzoffset)):\n   return NotImplemented\n   \n  return (isinstance(other,tzutc)or\n  (isinstance(other,tzoffset)and other._offset ==ZERO))\n  \n __hash__=None\n \n def __ne__(self,other):\n  return not (self ==other)\n  \n def __repr__(self):\n  return \"%s()\"%self.__class__.__name__\n  \n __reduce__=object.__reduce__\n \n \n \n \n \nUTC=tzutc()\n\n\n@six.add_metaclass(_TzOffsetFactory)\nclass tzoffset(datetime.tzinfo):\n ''\n\n\n\n\n\n\n\n \n def __init__(self,name,offset):\n  self._name=name\n  \n  try :\n  \n   offset=offset.total_seconds()\n  except (TypeError,AttributeError):\n   pass\n   \n  self._offset=datetime.timedelta(seconds=_get_supported_offset(offset))\n  \n def utcoffset(self,dt):\n  return self._offset\n  \n def dst(self,dt):\n  return ZERO\n  \n @tzname_in_python2\n def tzname(self,dt):\n  return self._name\n  \n @_validate_fromutc_inputs\n def fromutc(self,dt):\n  return dt+self._offset\n  \n def is_ambiguous(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  return False\n  \n def __eq__(self,other):\n  if not isinstance(other,tzoffset):\n   return NotImplemented\n   \n  return self._offset ==other._offset\n  \n __hash__=None\n \n def __ne__(self,other):\n  return not (self ==other)\n  \n def __repr__(self):\n  return \"%s(%s, %s)\"%(self.__class__.__name__,\n  repr(self._name),\n  int(self._offset.total_seconds()))\n  \n __reduce__=object.__reduce__\n \n \nclass tzlocal(_tzinfo):\n ''\n\n \n def __init__(self):\n  super(tzlocal,self).__init__()\n  \n  self._std_offset=datetime.timedelta(seconds=-time.timezone)\n  if time.daylight:\n   self._dst_offset=datetime.timedelta(seconds=-time.altzone)\n  else :\n   self._dst_offset=self._std_offset\n   \n  self._dst_saved=self._dst_offset -self._std_offset\n  self._hasdst=bool(self._dst_saved)\n  self._tznames=tuple(time.tzname)\n  \n def utcoffset(self,dt):\n  if dt is None and self._hasdst:\n   return None\n   \n  if self._isdst(dt):\n   return self._dst_offset\n  else :\n   return self._std_offset\n   \n def dst(self,dt):\n  if dt is None and self._hasdst:\n   return None\n   \n  if self._isdst(dt):\n   return self._dst_offset -self._std_offset\n  else :\n   return ZERO\n   \n @tzname_in_python2\n def tzname(self,dt):\n  return self._tznames[self._isdst(dt)]\n  \n def is_ambiguous(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  naive_dst=self._naive_is_dst(dt)\n  return (not naive_dst and\n  (naive_dst !=self._naive_is_dst(dt -self._dst_saved)))\n  \n def _naive_is_dst(self,dt):\n  timestamp=_datetime_to_timestamp(dt)\n  return time.localtime(timestamp+time.timezone).tm_isdst\n  \n def _isdst(self,dt,fold_naive=True ):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  if not self._hasdst:\n   return False\n   \n   \n  dstval=self._naive_is_dst(dt)\n  fold=getattr(dt,'fold',None )\n  \n  if self.is_ambiguous(dt):\n   if fold is not None :\n    return not self._fold(dt)\n   else :\n    return True\n    \n  return dstval\n  \n def __eq__(self,other):\n  if isinstance(other,tzlocal):\n   return (self._std_offset ==other._std_offset and\n   self._dst_offset ==other._dst_offset)\n  elif isinstance(other,tzutc):\n   return (not self._hasdst and\n   self._tznames[0]in {'UTC','GMT'}and\n   self._std_offset ==ZERO)\n  elif isinstance(other,tzoffset):\n   return (not self._hasdst and\n   self._tznames[0]==other._name and\n   self._std_offset ==other._offset)\n  else :\n   return NotImplemented\n   \n __hash__=None\n \n def __ne__(self,other):\n  return not (self ==other)\n  \n def __repr__(self):\n  return \"%s()\"%self.__class__.__name__\n  \n __reduce__=object.__reduce__\n \n \nclass _ttinfo(object):\n __slots__=[\"offset\",\"delta\",\"isdst\",\"abbr\",\n \"isstd\",\"isgmt\",\"dstoffset\"]\n \n def __init__(self):\n  for attr in self.__slots__:\n   setattr(self,attr,None )\n   \n def __repr__(self):\n  l=[]\n  for attr in self.__slots__:\n   value=getattr(self,attr)\n   if value is not None :\n    l.append(\"%s=%s\"%(attr,repr(value)))\n  return \"%s(%s)\"%(self.__class__.__name__,\", \".join(l))\n  \n def __eq__(self,other):\n  if not isinstance(other,_ttinfo):\n   return NotImplemented\n   \n  return (self.offset ==other.offset and\n  self.delta ==other.delta and\n  self.isdst ==other.isdst and\n  self.abbr ==other.abbr and\n  self.isstd ==other.isstd and\n  self.isgmt ==other.isgmt and\n  self.dstoffset ==other.dstoffset)\n  \n __hash__=None\n \n def __ne__(self,other):\n  return not (self ==other)\n  \n def __getstate__(self):\n  state={}\n  for name in self.__slots__:\n   state[name]=getattr(self,name,None )\n  return state\n  \n def __setstate__(self,state):\n  for name in self.__slots__:\n   if name in state:\n    setattr(self,name,state[name])\n    \n    \nclass _tzfile(object):\n ''\n\n\n \n attrs=['trans_list','trans_list_utc','trans_idx','ttinfo_list',\n 'ttinfo_std','ttinfo_dst','ttinfo_before','ttinfo_first']\n \n def __init__(self,**kwargs):\n  for attr in self.attrs:\n   setattr(self,attr,kwargs.get(attr,None ))\n   \n   \nclass tzfile(_tzinfo):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,fileobj,filename=None ):\n  super(tzfile,self).__init__()\n  \n  file_opened_here=False\n  if isinstance(fileobj,string_types):\n   self._filename=fileobj\n   fileobj=open(fileobj,'rb')\n   file_opened_here=True\n  elif filename is not None :\n   self._filename=filename\n  elif hasattr(fileobj,\"name\"):\n   self._filename=fileobj.name\n  else :\n   self._filename=repr(fileobj)\n   \n  if fileobj is not None :\n   if not file_opened_here:\n    fileobj=_nullcontext(fileobj)\n    \n   with fileobj as file_stream:\n    tzobj=self._read_tzfile(file_stream)\n    \n   self._set_tzdata(tzobj)\n   \n def _set_tzdata(self,tzobj):\n  ''\n  \n  for attr in _tzfile.attrs:\n   setattr(self,'_'+attr,getattr(tzobj,attr))\n   \n def _read_tzfile(self,fileobj):\n  out=_tzfile()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if fileobj.read(4).decode()!=\"TZif\":\n   raise ValueError(\"magic not found\")\n   \n  fileobj.read(16)\n  \n  (\n  \n  ttisgmtcnt,\n  \n  \n  ttisstdcnt,\n  \n  \n  \n  leapcnt,\n  \n  \n  \n  timecnt,\n  \n  \n  \n  typecnt,\n  \n  \n  \n  charcnt,\n  \n  )=struct.unpack(\">6l\",fileobj.read(24))\n  \n  \n  \n  \n  \n  \n  \n  \n  if timecnt:\n   out.trans_list_utc=list(struct.unpack(\">%dl\"%timecnt,\n   fileobj.read(timecnt *4)))\n  else :\n   out.trans_list_utc=[]\n   \n   \n   \n   \n   \n   \n   \n   \n  if timecnt:\n   out.trans_idx=struct.unpack(\">%dB\"%timecnt,\n   fileobj.read(timecnt))\n  else :\n   out.trans_idx=[]\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  ttinfo=[]\n  \n  for i in range(typecnt):\n   ttinfo.append(struct.unpack(\">lbb\",fileobj.read(6)))\n   \n  abbr=fileobj.read(charcnt).decode()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if leapcnt:\n   fileobj.seek(leapcnt *8,os.SEEK_CUR)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if ttisstdcnt:\n   isstd=struct.unpack(\">%db\"%ttisstdcnt,\n   fileobj.read(ttisstdcnt))\n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if ttisgmtcnt:\n   isgmt=struct.unpack(\">%db\"%ttisgmtcnt,\n   fileobj.read(ttisgmtcnt))\n   \n   \n  out.ttinfo_list=[]\n  for i in range(typecnt):\n   gmtoff,isdst,abbrind=ttinfo[i]\n   gmtoff=_get_supported_offset(gmtoff)\n   tti=_ttinfo()\n   tti.offset=gmtoff\n   tti.dstoffset=datetime.timedelta(0)\n   tti.delta=datetime.timedelta(seconds=gmtoff)\n   tti.isdst=isdst\n   tti.abbr=abbr[abbrind:abbr.find('\\x00',abbrind)]\n   tti.isstd=(ttisstdcnt >i and isstd[i]!=0)\n   tti.isgmt=(ttisgmtcnt >i and isgmt[i]!=0)\n   out.ttinfo_list.append(tti)\n   \n   \n  out.trans_idx=[out.ttinfo_list[idx]for idx in out.trans_idx]\n  \n  \n  \n  \n  \n  out.ttinfo_std=None\n  out.ttinfo_dst=None\n  out.ttinfo_before=None\n  if out.ttinfo_list:\n   if not out.trans_list_utc:\n    out.ttinfo_std=out.ttinfo_first=out.ttinfo_list[0]\n   else :\n    for i in range(timecnt -1,-1,-1):\n     tti=out.trans_idx[i]\n     if not out.ttinfo_std and not tti.isdst:\n      out.ttinfo_std=tti\n     elif not out.ttinfo_dst and tti.isdst:\n      out.ttinfo_dst=tti\n      \n     if out.ttinfo_std and out.ttinfo_dst:\n      break\n    else :\n     if out.ttinfo_dst and not out.ttinfo_std:\n      out.ttinfo_std=out.ttinfo_dst\n      \n    for tti in out.ttinfo_list:\n     if not tti.isdst:\n      out.ttinfo_before=tti\n      break\n    else :\n     out.ttinfo_before=out.ttinfo_list[0]\n     \n     \n     \n     \n     \n     \n     \n     \n  lastdst=None\n  lastoffset=None\n  lastdstoffset=None\n  lastbaseoffset=None\n  out.trans_list=[]\n  \n  for i,tti in enumerate(out.trans_idx):\n   offset=tti.offset\n   dstoffset=0\n   \n   if lastdst is not None :\n    if tti.isdst:\n     if not lastdst:\n      dstoffset=offset -lastoffset\n      \n     if not dstoffset and lastdstoffset:\n      dstoffset=lastdstoffset\n      \n     tti.dstoffset=datetime.timedelta(seconds=dstoffset)\n     lastdstoffset=dstoffset\n     \n     \n     \n     \n     \n     \n   baseoffset=offset -dstoffset\n   adjustment=baseoffset\n   if (lastbaseoffset is not None and baseoffset !=lastbaseoffset\n   and tti.isdst !=lastdst):\n   \n    adjustment=lastbaseoffset\n    \n   lastdst=tti.isdst\n   lastoffset=offset\n   lastbaseoffset=baseoffset\n   \n   out.trans_list.append(out.trans_list_utc[i]+adjustment)\n   \n  out.trans_idx=tuple(out.trans_idx)\n  out.trans_list=tuple(out.trans_list)\n  out.trans_list_utc=tuple(out.trans_list_utc)\n  \n  return out\n  \n def _find_last_transition(self,dt,in_utc=False ):\n \n  if not self._trans_list:\n   return None\n   \n  timestamp=_datetime_to_timestamp(dt)\n  \n  \n  \n  trans_list=self._trans_list_utc if in_utc else self._trans_list\n  idx=bisect.bisect_right(trans_list,timestamp)\n  \n  \n  return idx -1\n  \n def _get_ttinfo(self,idx):\n \n  if idx is None or (idx+1)>=len(self._trans_list):\n   return self._ttinfo_std\n   \n   \n  if idx <0:\n   return self._ttinfo_before\n   \n  return self._trans_idx[idx]\n  \n def _find_ttinfo(self,dt):\n  idx=self._resolve_ambiguous_time(dt)\n  \n  return self._get_ttinfo(idx)\n  \n def fromutc(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  if not isinstance(dt,datetime.datetime):\n   raise TypeError(\"fromutc() requires a datetime argument\")\n   \n  if dt.tzinfo is not self:\n   raise ValueError(\"dt.tzinfo is not self\")\n   \n   \n  idx=self._find_last_transition(dt,in_utc=True )\n  tti=self._get_ttinfo(idx)\n  \n  dt_out=dt+datetime.timedelta(seconds=tti.offset)\n  \n  fold=self.is_ambiguous(dt_out,idx=idx)\n  \n  return enfold(dt_out,fold=int(fold))\n  \n def is_ambiguous(self,dt,idx=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if idx is None :\n   idx=self._find_last_transition(dt)\n   \n   \n  timestamp=_datetime_to_timestamp(dt)\n  tti=self._get_ttinfo(idx)\n  \n  if idx is None or idx <=0:\n   return False\n   \n  od=self._get_ttinfo(idx -1).offset -tti.offset\n  tt=self._trans_list[idx]\n  \n  return timestamp <tt+od\n  \n def _resolve_ambiguous_time(self,dt):\n  idx=self._find_last_transition(dt)\n  \n  \n  _fold=self._fold(dt)\n  if idx is None or idx ==0:\n   return idx\n   \n   \n  idx_offset=int(not _fold and self.is_ambiguous(dt,idx))\n  \n  return idx -idx_offset\n  \n def utcoffset(self,dt):\n  if dt is None :\n   return None\n   \n  if not self._ttinfo_std:\n   return ZERO\n   \n  return self._find_ttinfo(dt).delta\n  \n def dst(self,dt):\n  if dt is None :\n   return None\n   \n  if not self._ttinfo_dst:\n   return ZERO\n   \n  tti=self._find_ttinfo(dt)\n  \n  if not tti.isdst:\n   return ZERO\n   \n   \n   \n  return tti.dstoffset\n  \n @tzname_in_python2\n def tzname(self,dt):\n  if not self._ttinfo_std or dt is None :\n   return None\n  return self._find_ttinfo(dt).abbr\n  \n def __eq__(self,other):\n  if not isinstance(other,tzfile):\n   return NotImplemented\n  return (self._trans_list ==other._trans_list and\n  self._trans_idx ==other._trans_idx and\n  self._ttinfo_list ==other._ttinfo_list)\n  \n __hash__=None\n \n def __ne__(self,other):\n  return not (self ==other)\n  \n def __repr__(self):\n  return \"%s(%s)\"%(self.__class__.__name__,repr(self._filename))\n  \n def __reduce__(self):\n  return self.__reduce_ex__(None )\n  \n def __reduce_ex__(self,protocol):\n  return (self.__class__,(None ,self._filename),self.__dict__)\n  \n  \nclass tzrange(tzrangebase):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,stdabbr,stdoffset=None ,\n dstabbr=None ,dstoffset=None ,\n start=None ,end=None ):\n \n  global relativedelta\n  from dateutil import relativedelta\n  \n  self._std_abbr=stdabbr\n  self._dst_abbr=dstabbr\n  \n  try :\n   stdoffset=stdoffset.total_seconds()\n  except (TypeError,AttributeError):\n   pass\n   \n  try :\n   dstoffset=dstoffset.total_seconds()\n  except (TypeError,AttributeError):\n   pass\n   \n  if stdoffset is not None :\n   self._std_offset=datetime.timedelta(seconds=stdoffset)\n  else :\n   self._std_offset=ZERO\n   \n  if dstoffset is not None :\n   self._dst_offset=datetime.timedelta(seconds=dstoffset)\n  elif dstabbr and stdoffset is not None :\n   self._dst_offset=self._std_offset+datetime.timedelta(hours=+1)\n  else :\n   self._dst_offset=ZERO\n   \n  if dstabbr and start is None :\n   self._start_delta=relativedelta.relativedelta(\n   hours=+2,month=4,day=1,weekday=relativedelta.SU(+1))\n  else :\n   self._start_delta=start\n   \n  if dstabbr and end is None :\n   self._end_delta=relativedelta.relativedelta(\n   hours=+1,month=10,day=31,weekday=relativedelta.SU(-1))\n  else :\n   self._end_delta=end\n   \n  self._dst_base_offset_=self._dst_offset -self._std_offset\n  self.hasdst=bool(self._start_delta)\n  \n def transitions(self,year):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not self.hasdst:\n   return None\n   \n  base_year=datetime.datetime(year,1,1)\n  \n  start=base_year+self._start_delta\n  end=base_year+self._end_delta\n  \n  return (start,end)\n  \n def __eq__(self,other):\n  if not isinstance(other,tzrange):\n   return NotImplemented\n   \n  return (self._std_abbr ==other._std_abbr and\n  self._dst_abbr ==other._dst_abbr and\n  self._std_offset ==other._std_offset and\n  self._dst_offset ==other._dst_offset and\n  self._start_delta ==other._start_delta and\n  self._end_delta ==other._end_delta)\n  \n @property\n def _dst_base_offset(self):\n  return self._dst_base_offset_\n  \n  \n@six.add_metaclass(_TzStrFactory)\nclass tzstr(tzrange):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,s,posix_offset=False ):\n  global parser\n  from dateutil.parser import _parser as parser\n  \n  self._s=s\n  \n  res=parser._parsetz(s)\n  if res is None or res.any_unused_tokens:\n   raise ValueError(\"unknown string format\")\n   \n   \n   \n  if res.stdabbr in (\"GMT\",\"UTC\")and not posix_offset:\n   res.stdoffset *=-1\n   \n   \n   \n   \n  tzrange.__init__(self,res.stdabbr,res.stdoffset,\n  res.dstabbr,res.dstoffset,\n  start=False ,end=False )\n  \n  if not res.dstabbr:\n   self._start_delta=None\n   self._end_delta=None\n  else :\n   self._start_delta=self._delta(res.start)\n   if self._start_delta:\n    self._end_delta=self._delta(res.end,isend=1)\n    \n  self.hasdst=bool(self._start_delta)\n  \n def _delta(self,x,isend=0):\n  from dateutil import relativedelta\n  kwargs={}\n  if x.month is not None :\n   kwargs[\"month\"]=x.month\n   if x.weekday is not None :\n    kwargs[\"weekday\"]=relativedelta.weekday(x.weekday,x.week)\n    if x.week >0:\n     kwargs[\"day\"]=1\n    else :\n     kwargs[\"day\"]=31\n   elif x.day:\n    kwargs[\"day\"]=x.day\n  elif x.yday is not None :\n   kwargs[\"yearday\"]=x.yday\n  elif x.jyday is not None :\n   kwargs[\"nlyearday\"]=x.jyday\n  if not kwargs:\n  \n  \n   if not isend:\n    kwargs[\"month\"]=4\n    kwargs[\"day\"]=1\n    kwargs[\"weekday\"]=relativedelta.SU(+1)\n   else :\n    kwargs[\"month\"]=10\n    kwargs[\"day\"]=31\n    kwargs[\"weekday\"]=relativedelta.SU(-1)\n  if x.time is not None :\n   kwargs[\"seconds\"]=x.time\n  else :\n  \n   kwargs[\"seconds\"]=7200\n  if isend:\n  \n  \n  \n   delta=self._dst_offset -self._std_offset\n   kwargs[\"seconds\"]-=delta.seconds+delta.days *86400\n  return relativedelta.relativedelta(**kwargs)\n  \n def __repr__(self):\n  return \"%s(%s)\"%(self.__class__.__name__,repr(self._s))\n  \n  \nclass _tzicalvtzcomp(object):\n def __init__(self,tzoffsetfrom,tzoffsetto,isdst,\n tzname=None ,rrule=None ):\n  self.tzoffsetfrom=datetime.timedelta(seconds=tzoffsetfrom)\n  self.tzoffsetto=datetime.timedelta(seconds=tzoffsetto)\n  self.tzoffsetdiff=self.tzoffsetto -self.tzoffsetfrom\n  self.isdst=isdst\n  self.tzname=tzname\n  self.rrule=rrule\n  \n  \nclass _tzicalvtz(_tzinfo):\n def __init__(self,tzid,comps=[]):\n  super(_tzicalvtz,self).__init__()\n  \n  self._tzid=tzid\n  self._comps=comps\n  self._cachedate=[]\n  self._cachecomp=[]\n  self._cache_lock=_thread.allocate_lock()\n  \n def _find_comp(self,dt):\n  if len(self._comps)==1:\n   return self._comps[0]\n   \n  dt=dt.replace(tzinfo=None )\n  \n  try :\n   with self._cache_lock:\n    return self._cachecomp[self._cachedate.index(\n    (dt,self._fold(dt)))]\n  except ValueError:\n   pass\n   \n  lastcompdt=None\n  lastcomp=None\n  \n  for comp in self._comps:\n   compdt=self._find_compdt(comp,dt)\n   \n   if compdt and (not lastcompdt or lastcompdt <compdt):\n    lastcompdt=compdt\n    lastcomp=comp\n    \n  if not lastcomp:\n  \n  \n  \n  \n   for comp in self._comps:\n    if not comp.isdst:\n     lastcomp=comp\n     break\n   else :\n    lastcomp=comp[0]\n    \n  with self._cache_lock:\n   self._cachedate.insert(0,(dt,self._fold(dt)))\n   self._cachecomp.insert(0,lastcomp)\n   \n   if len(self._cachedate)>10:\n    self._cachedate.pop()\n    self._cachecomp.pop()\n    \n  return lastcomp\n  \n def _find_compdt(self,comp,dt):\n  if comp.tzoffsetdiff <ZERO and self._fold(dt):\n   dt -=comp.tzoffsetdiff\n   \n  compdt=comp.rrule.before(dt,inc=True )\n  \n  return compdt\n  \n def utcoffset(self,dt):\n  if dt is None :\n   return None\n   \n  return self._find_comp(dt).tzoffsetto\n  \n def dst(self,dt):\n  comp=self._find_comp(dt)\n  if comp.isdst:\n   return comp.tzoffsetdiff\n  else :\n   return ZERO\n   \n @tzname_in_python2\n def tzname(self,dt):\n  return self._find_comp(dt).tzname\n  \n def __repr__(self):\n  return \"<tzicalvtz %s>\"%repr(self._tzid)\n  \n __reduce__=object.__reduce__\n \n \nclass tzical(object):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,fileobj):\n  global rrule\n  from dateutil import rrule\n  \n  if isinstance(fileobj,string_types):\n   self._s=fileobj\n   \n   fileobj=open(fileobj,'r')\n  else :\n   self._s=getattr(fileobj,'name',repr(fileobj))\n   fileobj=_nullcontext(fileobj)\n   \n  self._vtz={}\n  \n  with fileobj as fobj:\n   self._parse_rfc(fobj.read())\n   \n def keys(self):\n  ''\n\n  \n  return list(self._vtz.keys())\n  \n def get(self,tzid=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if tzid is None :\n   if len(self._vtz)==0:\n    raise ValueError(\"no timezones defined\")\n   elif len(self._vtz)>1:\n    raise ValueError(\"more than one timezone available\")\n   tzid=next(iter(self._vtz))\n   \n  return self._vtz.get(tzid)\n  \n def _parse_offset(self,s):\n  s=s.strip()\n  if not s:\n   raise ValueError(\"empty offset\")\n  if s[0]in ('+','-'):\n   signal=(-1,+1)[s[0]=='+']\n   s=s[1:]\n  else :\n   signal=+1\n  if len(s)==4:\n   return (int(s[:2])*3600+int(s[2:])*60)*signal\n  elif len(s)==6:\n   return (int(s[:2])*3600+int(s[2:4])*60+int(s[4:]))*signal\n  else :\n   raise ValueError(\"invalid offset: \"+s)\n   \n def _parse_rfc(self,s):\n  lines=s.splitlines()\n  if not lines:\n   raise ValueError(\"empty string\")\n   \n   \n  i=0\n  while i <len(lines):\n   line=lines[i].rstrip()\n   if not line:\n    del lines[i]\n   elif i >0 and line[0]==\" \":\n    lines[i -1]+=line[1:]\n    del lines[i]\n   else :\n    i +=1\n    \n  tzid=None\n  comps=[]\n  invtz=False\n  comptype=None\n  for line in lines:\n   if not line:\n    continue\n   name,value=line.split(':',1)\n   parms=name.split(';')\n   if not parms:\n    raise ValueError(\"empty property name\")\n   name=parms[0].upper()\n   parms=parms[1:]\n   if invtz:\n    if name ==\"BEGIN\":\n     if value in (\"STANDARD\",\"DAYLIGHT\"):\n     \n      pass\n     else :\n      raise ValueError(\"unknown component: \"+value)\n     comptype=value\n     founddtstart=False\n     tzoffsetfrom=None\n     tzoffsetto=None\n     rrulelines=[]\n     tzname=None\n    elif name ==\"END\":\n     if value ==\"VTIMEZONE\":\n      if comptype:\n       raise ValueError(\"component not closed: \"+comptype)\n      if not tzid:\n       raise ValueError(\"mandatory TZID not found\")\n      if not comps:\n       raise ValueError(\n       \"at least one component is needed\")\n       \n      self._vtz[tzid]=_tzicalvtz(tzid,comps)\n      invtz=False\n     elif value ==comptype:\n      if not founddtstart:\n       raise ValueError(\"mandatory DTSTART not found\")\n      if tzoffsetfrom is None :\n       raise ValueError(\n       \"mandatory TZOFFSETFROM not found\")\n      if tzoffsetto is None :\n       raise ValueError(\n       \"mandatory TZOFFSETFROM not found\")\n       \n      rr=None\n      if rrulelines:\n       rr=rrule.rrulestr(\"\\n\".join(rrulelines),\n       compatible=True ,\n       ignoretz=True ,\n       cache=True )\n      comp=_tzicalvtzcomp(tzoffsetfrom,tzoffsetto,\n      (comptype ==\"DAYLIGHT\"),\n      tzname,rr)\n      comps.append(comp)\n      comptype=None\n     else :\n      raise ValueError(\"invalid component end: \"+value)\n    elif comptype:\n     if name ==\"DTSTART\":\n     \n     \n      for parm in parms:\n       if parm !='VALUE=DATE-TIME':\n        msg=('Unsupported DTSTART param in '+\n        'VTIMEZONE: '+parm)\n        raise ValueError(msg)\n      rrulelines.append(line)\n      founddtstart=True\n     elif name in (\"RRULE\",\"RDATE\",\"EXRULE\",\"EXDATE\"):\n      rrulelines.append(line)\n     elif name ==\"TZOFFSETFROM\":\n      if parms:\n       raise ValueError(\n       \"unsupported %s parm: %s \"%(name,parms[0]))\n      tzoffsetfrom=self._parse_offset(value)\n     elif name ==\"TZOFFSETTO\":\n      if parms:\n       raise ValueError(\n       \"unsupported TZOFFSETTO parm: \"+parms[0])\n      tzoffsetto=self._parse_offset(value)\n     elif name ==\"TZNAME\":\n      if parms:\n       raise ValueError(\n       \"unsupported TZNAME parm: \"+parms[0])\n      tzname=value\n     elif name ==\"COMMENT\":\n      pass\n     else :\n      raise ValueError(\"unsupported property: \"+name)\n    else :\n     if name ==\"TZID\":\n      if parms:\n       raise ValueError(\n       \"unsupported TZID parm: \"+parms[0])\n      tzid=value\n     elif name in (\"TZURL\",\"LAST-MODIFIED\",\"COMMENT\"):\n      pass\n     else :\n      raise ValueError(\"unsupported property: \"+name)\n   elif name ==\"BEGIN\"and value ==\"VTIMEZONE\":\n    tzid=None\n    comps=[]\n    invtz=True\n    \n def __repr__(self):\n  return \"%s(%s)\"%(self.__class__.__name__,repr(self._s))\n  \n  \nif sys.platform !=\"win32\":\n TZFILES=[\"/etc/localtime\",\"localtime\"]\n TZPATHS=[\"/usr/share/zoneinfo\",\n \"/usr/lib/zoneinfo\",\n \"/usr/share/lib/zoneinfo\",\n \"/etc/zoneinfo\"]\nelse :\n TZFILES=[]\n TZPATHS=[]\n \n \ndef __get_gettz():\n tzlocal_classes=(tzlocal,)\n if tzwinlocal is not None :\n  tzlocal_classes +=(tzwinlocal,)\n  \n class GettzFunc(object):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  def __init__(self):\n  \n   self.__instances=weakref.WeakValueDictionary()\n   self.__strong_cache_size=8\n   self.__strong_cache=OrderedDict()\n   self._cache_lock=_thread.allocate_lock()\n   \n  def __call__(self,name=None ):\n   with self._cache_lock:\n    rv=self.__instances.get(name,None )\n    \n    if rv is None :\n     rv=self.nocache(name=name)\n     if not (name is None\n     or isinstance(rv,tzlocal_classes)\n     or rv is None ):\n     \n     \n     \n     \n     \n     \n      self.__instances[name]=rv\n     else :\n     \n      return rv\n      \n    self.__strong_cache[name]=self.__strong_cache.pop(name,rv)\n    \n    if len(self.__strong_cache)>self.__strong_cache_size:\n     self.__strong_cache.popitem(last=False )\n     \n   return rv\n   \n  def set_cache_size(self,size):\n   with self._cache_lock:\n    self.__strong_cache_size=size\n    while len(self.__strong_cache)>size:\n     self.__strong_cache.popitem(last=False )\n     \n  def cache_clear(self):\n   with self._cache_lock:\n    self.__instances=weakref.WeakValueDictionary()\n    self.__strong_cache.clear()\n    \n  @staticmethod\n  def nocache(name=None ):\n   ''\n   tz=None\n   if not name:\n    try :\n     name=os.environ[\"TZ\"]\n    except KeyError:\n     pass\n   if name is None or name in (\"\",\":\"):\n    for filepath in TZFILES:\n     if not os.path.isabs(filepath):\n      filename=filepath\n      for path in TZPATHS:\n       filepath=os.path.join(path,filename)\n       if os.path.isfile(filepath):\n        break\n      else :\n       continue\n     if os.path.isfile(filepath):\n      try :\n       tz=tzfile(filepath)\n       break\n      except (IOError,OSError,ValueError):\n       pass\n    else :\n     tz=tzlocal()\n   else :\n    try :\n     if name.startswith(\":\"):\n      name=name[1:]\n    except TypeError as e:\n     if isinstance(name,bytes):\n      new_msg=\"gettz argument should be str, not bytes\"\n      six.raise_from(TypeError(new_msg),e)\n     else :\n      raise\n    if os.path.isabs(name):\n     if os.path.isfile(name):\n      tz=tzfile(name)\n     else :\n      tz=None\n    else :\n     for path in TZPATHS:\n      filepath=os.path.join(path,name)\n      if not os.path.isfile(filepath):\n       filepath=filepath.replace(' ','_')\n       if not os.path.isfile(filepath):\n        continue\n      try :\n       tz=tzfile(filepath)\n       break\n      except (IOError,OSError,ValueError):\n       pass\n     else :\n      tz=None\n      if tzwin is not None :\n       try :\n        tz=tzwin(name)\n       except (WindowsError,UnicodeEncodeError):\n       \n        tz=None\n        \n      if not tz:\n       from dateutil.zoneinfo import get_zonefile_instance\n       tz=get_zonefile_instance().get(name)\n       \n      if not tz:\n       for c in name:\n       \n       \n       \n       \n        if c in \"0123456789\":\n         try :\n          tz=tzstr(name)\n         except ValueError:\n          pass\n         break\n       else :\n        if name in (\"GMT\",\"UTC\"):\n         tz=UTC\n        elif name in time.tzname:\n         tz=tzlocal()\n   return tz\n   \n return GettzFunc()\n \n \ngettz=__get_gettz()\ndel __get_gettz\n\n\ndef datetime_exists(dt,tz=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if tz is None :\n  if dt.tzinfo is None :\n   raise ValueError('Datetime is naive and no time zone provided.')\n  tz=dt.tzinfo\n  \n dt=dt.replace(tzinfo=None )\n \n \n \n dt_rt=dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)\n dt_rt=dt_rt.replace(tzinfo=None )\n \n return dt ==dt_rt\n \n \ndef datetime_ambiguous(dt,tz=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if tz is None :\n  if dt.tzinfo is None :\n   raise ValueError('Datetime is naive and no time zone provided.')\n   \n  tz=dt.tzinfo\n  \n  \n is_ambiguous_fn=getattr(tz,'is_ambiguous',None )\n if is_ambiguous_fn is not None :\n  try :\n   return tz.is_ambiguous(dt)\n  except Exception:\n   pass\n   \n   \n   \n dt=dt.replace(tzinfo=tz)\n wall_0=enfold(dt,fold=0)\n wall_1=enfold(dt,fold=1)\n \n same_offset=wall_0.utcoffset()==wall_1.utcoffset()\n same_dst=wall_0.dst()==wall_1.dst()\n \n return not (same_offset and same_dst)\n \n \ndef resolve_imaginary(dt):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if dt.tzinfo is not None and not datetime_exists(dt):\n \n  curr_offset=(dt+datetime.timedelta(hours=24)).utcoffset()\n  old_offset=(dt -datetime.timedelta(hours=24)).utcoffset()\n  \n  dt +=curr_offset -old_offset\n  \n return dt\n \n \ndef _datetime_to_timestamp(dt):\n ''\n\n\n \n return (dt.replace(tzinfo=None )-EPOCH).total_seconds()\n \n \nif sys.version_info >=(3,6):\n def _get_supported_offset(second_offset):\n  return second_offset\nelse :\n def _get_supported_offset(second_offset):\n \n \n \n \n  old_offset=second_offset\n  calculated_offset=60 *((second_offset+30)//60)\n  return calculated_offset\n  \n  \ntry :\n\n from contextlib import nullcontext as _nullcontext\nexcept ImportError:\n class _nullcontext(object):\n  ''\n\n\n  \n  def __init__(self,context):\n   self.context=context\n   \n  def __enter__(self):\n   return self.context\n   \n  def __exit__(*args,**kwargs):\n   pass\n   \n   \n", ["bisect", "collections", "contextlib", "datetime", "dateutil", "dateutil.parser", "dateutil.parser._parser", "dateutil.relativedelta", "dateutil.rrule", "dateutil.tz._common", "dateutil.tz._factories", "dateutil.tz.win", "dateutil.zoneinfo", "os", "six", "six.moves", "struct", "sys", "time", "warnings", "weakref"]], "dateutil.tz._factories": [".py", "from datetime import timedelta\nimport weakref\nfrom collections import OrderedDict\n\nfrom six.moves import _thread\n\n\nclass _TzSingleton(type):\n def __init__(cls,*args,**kwargs):\n  cls.__instance=None\n  super(_TzSingleton,cls).__init__(*args,**kwargs)\n  \n def __call__(cls):\n  if cls.__instance is None :\n   cls.__instance=super(_TzSingleton,cls).__call__()\n  return cls.__instance\n  \n  \nclass _TzFactory(type):\n def instance(cls,*args,**kwargs):\n  ''\n  return type.__call__(cls,*args,**kwargs)\n  \n  \nclass _TzOffsetFactory(_TzFactory):\n def __init__(cls,*args,**kwargs):\n  cls.__instances=weakref.WeakValueDictionary()\n  cls.__strong_cache=OrderedDict()\n  cls.__strong_cache_size=8\n  \n  cls._cache_lock=_thread.allocate_lock()\n  \n def __call__(cls,name,offset):\n  if isinstance(offset,timedelta):\n   key=(name,offset.total_seconds())\n  else :\n   key=(name,offset)\n   \n  instance=cls.__instances.get(key,None )\n  if instance is None :\n   instance=cls.__instances.setdefault(key,\n   cls.instance(name,offset))\n   \n   \n  with cls._cache_lock:\n   cls.__strong_cache[key]=cls.__strong_cache.pop(key,instance)\n   \n   \n   if len(cls.__strong_cache)>cls.__strong_cache_size:\n    cls.__strong_cache.popitem(last=False )\n    \n  return instance\n  \n  \nclass _TzStrFactory(_TzFactory):\n def __init__(cls,*args,**kwargs):\n  cls.__instances=weakref.WeakValueDictionary()\n  cls.__strong_cache=OrderedDict()\n  cls.__strong_cache_size=8\n  \n  cls.__cache_lock=_thread.allocate_lock()\n  \n def __call__(cls,s,posix_offset=False ):\n  key=(s,posix_offset)\n  instance=cls.__instances.get(key,None )\n  \n  if instance is None :\n   instance=cls.__instances.setdefault(key,\n   cls.instance(s,posix_offset))\n   \n   \n  with cls.__cache_lock:\n   cls.__strong_cache[key]=cls.__strong_cache.pop(key,instance)\n   \n   \n   if len(cls.__strong_cache)>cls.__strong_cache_size:\n    cls.__strong_cache.popitem(last=False )\n    \n  return instance\n  \n", ["collections", "datetime", "six.moves", "weakref"]], "dateutil.tz._common": [".py", "from six import PY2\n\nfrom functools import wraps\n\nfrom datetime import datetime,timedelta,tzinfo\n\n\nZERO=timedelta(0)\n\n__all__=['tzname_in_python2','enfold']\n\n\ndef tzname_in_python2(namefunc):\n ''\n\n\n\n \n if PY2:\n  @wraps(namefunc)\n  def adjust_encoding(*args,**kwargs):\n   name=namefunc(*args,**kwargs)\n   if name is not None :\n    name=name.encode()\n    \n   return name\n   \n  return adjust_encoding\n else :\n  return namefunc\n  \n  \n  \n  \nif hasattr(datetime,'fold'):\n\n def enfold(dt,fold=1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return dt.replace(fold=fold)\n  \nelse :\n class _DatetimeWithFold(datetime):\n  ''\n\n\n\n\n\n  \n  __slots__=()\n  \n  def replace(self,*args,**kwargs):\n   ''\n\n\n\n\n\n\n\n\n   \n   argnames=(\n   'year','month','day','hour','minute','second',\n   'microsecond','tzinfo'\n   )\n   \n   for arg,argname in zip(args,argnames):\n    if argname in kwargs:\n     raise TypeError('Duplicate argument: {}'.format(argname))\n     \n    kwargs[argname]=arg\n    \n   for argname in argnames:\n    if argname not in kwargs:\n     kwargs[argname]=getattr(self,argname)\n     \n   dt_class=self.__class__ if kwargs.get('fold',1)else datetime\n   \n   return dt_class(**kwargs)\n   \n  @property\n  def fold(self):\n   return 1\n   \n def enfold(dt,fold=1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if getattr(dt,'fold',0)==fold:\n   return dt\n   \n  args=dt.timetuple()[:6]\n  args +=(dt.microsecond,dt.tzinfo)\n  \n  if fold:\n   return _DatetimeWithFold(*args)\n  else :\n   return datetime(*args)\n   \n   \ndef _validate_fromutc_inputs(f):\n ''\n\n\n \n @wraps(f)\n def fromutc(self,dt):\n  if not isinstance(dt,datetime):\n   raise TypeError(\"fromutc() requires a datetime argument\")\n  if dt.tzinfo is not self:\n   raise ValueError(\"dt.tzinfo is not self\")\n   \n  return f(self,dt)\n  \n return fromutc\n \n \nclass _tzinfo(tzinfo):\n ''\n\n \n \n def is_ambiguous(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  dt=dt.replace(tzinfo=self)\n  \n  wall_0=enfold(dt,fold=0)\n  wall_1=enfold(dt,fold=1)\n  \n  same_offset=wall_0.utcoffset()==wall_1.utcoffset()\n  same_dt=wall_0.replace(tzinfo=None )==wall_1.replace(tzinfo=None )\n  \n  return same_dt and not same_offset\n  \n def _fold_status(self,dt_utc,dt_wall):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.is_ambiguous(dt_wall):\n   delta_wall=dt_wall -dt_utc\n   _fold=int(delta_wall ==(dt_utc.utcoffset()-dt_utc.dst()))\n  else :\n   _fold=0\n   \n  return _fold\n  \n def _fold(self,dt):\n  return getattr(dt,'fold',0)\n  \n def _fromutc(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  dtoff=dt.utcoffset()\n  if dtoff is None :\n   raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n   \"result\")\n   \n   \n   \n   \n  dtdst=dt.dst()\n  if dtdst is None :\n   raise ValueError(\"fromutc() requires a non-None dst() result\")\n  delta=dtoff -dtdst\n  \n  dt +=delta\n  \n  \n  dtdst=enfold(dt,fold=1).dst()\n  if dtdst is None :\n   raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n   \"results; cannot convert\")\n  return dt+dtdst\n  \n @_validate_fromutc_inputs\n def fromutc(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  dt_wall=self._fromutc(dt)\n  \n  \n  _fold=self._fold_status(dt,dt_wall)\n  \n  \n  return enfold(dt_wall,fold=_fold)\n  \n  \nclass tzrangebase(_tzinfo):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self):\n  raise NotImplementedError('tzrangebase is an abstract base class')\n  \n def utcoffset(self,dt):\n  isdst=self._isdst(dt)\n  \n  if isdst is None :\n   return None\n  elif isdst:\n   return self._dst_offset\n  else :\n   return self._std_offset\n   \n def dst(self,dt):\n  isdst=self._isdst(dt)\n  \n  if isdst is None :\n   return None\n  elif isdst:\n   return self._dst_base_offset\n  else :\n   return ZERO\n   \n @tzname_in_python2\n def tzname(self,dt):\n  if self._isdst(dt):\n   return self._dst_abbr\n  else :\n   return self._std_abbr\n   \n def fromutc(self,dt):\n  ''\n  if not isinstance(dt,datetime):\n   raise TypeError(\"fromutc() requires a datetime argument\")\n   \n  if dt.tzinfo is not self:\n   raise ValueError(\"dt.tzinfo is not self\")\n   \n   \n  transitions=self.transitions(dt.year)\n  if transitions is None :\n   return dt+self.utcoffset(dt)\n   \n   \n  dston,dstoff=transitions\n  \n  dston -=self._std_offset\n  dstoff -=self._std_offset\n  \n  utc_transitions=(dston,dstoff)\n  dt_utc=dt.replace(tzinfo=None )\n  \n  isdst=self._naive_isdst(dt_utc,utc_transitions)\n  \n  if isdst:\n   dt_wall=dt+self._dst_offset\n  else :\n   dt_wall=dt+self._std_offset\n   \n  _fold=int(not isdst and self.is_ambiguous(dt_wall))\n  \n  return enfold(dt_wall,fold=_fold)\n  \n def is_ambiguous(self,dt):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not self.hasdst:\n   return False\n   \n  start,end=self.transitions(dt.year)\n  \n  dt=dt.replace(tzinfo=None )\n  return (end <=dt <end+self._dst_base_offset)\n  \n def _isdst(self,dt):\n  if not self.hasdst:\n   return False\n  elif dt is None :\n   return None\n   \n  transitions=self.transitions(dt.year)\n  \n  if transitions is None :\n   return False\n   \n  dt=dt.replace(tzinfo=None )\n  \n  isdst=self._naive_isdst(dt,transitions)\n  \n  \n  if not isdst and self.is_ambiguous(dt):\n   return not self._fold(dt)\n  else :\n   return isdst\n   \n def _naive_isdst(self,dt,transitions):\n  dston,dstoff=transitions\n  \n  dt=dt.replace(tzinfo=None )\n  \n  if dston <dstoff:\n   isdst=dston <=dt <dstoff\n  else :\n   isdst=not dstoff <=dt <dston\n   \n  return isdst\n  \n @property\n def _dst_base_offset(self):\n  return self._dst_offset -self._std_offset\n  \n __hash__=None\n \n def __ne__(self,other):\n  return not (self ==other)\n  \n def __repr__(self):\n  return \"%s(...)\"%self.__class__.__name__\n  \n __reduce__=object.__reduce__\n", ["datetime", "functools", "six"]], "dateutil.tz": [".py", "\nfrom .tz import *\nfrom .tz import __doc__\n\n__all__=[\"tzutc\",\"tzoffset\",\"tzlocal\",\"tzfile\",\"tzrange\",\n\"tzstr\",\"tzical\",\"tzwin\",\"tzwinlocal\",\"gettz\",\n\"enfold\",\"datetime_ambiguous\",\"datetime_exists\",\n\"resolve_imaginary\",\"UTC\",\"DeprecatedTzFormatWarning\"]\n\n\nclass DeprecatedTzFormatWarning(Warning):\n ''\n", ["dateutil.tz.tz"], 1], "dateutil.parser.isoparser": [".py", "\n''\n\n\n\n\n\n\n\nfrom datetime import datetime,timedelta,time,date\nimport calendar\nfrom dateutil import tz\n\nfrom functools import wraps\n\nimport re\nimport six\n\n__all__=[\"isoparse\",\"isoparser\"]\n\n\ndef _takes_ascii(f):\n @wraps(f)\n def func(self,str_in,*args,**kwargs):\n \n  str_in=getattr(str_in,'read',lambda :str_in)()\n  \n  \n  if isinstance(str_in,six.text_type):\n  \n   try :\n    str_in=str_in.encode('ascii')\n   except UnicodeEncodeError as e:\n    msg='ISO-8601 strings should contain only ASCII characters'\n    six.raise_from(ValueError(msg),e)\n    \n  return f(self,str_in,*args,**kwargs)\n  \n return func\n \n \nclass isoparser(object):\n def __init__(self,sep=None ):\n  ''\n\n\n\n\n  \n  if sep is not None :\n   if (len(sep)!=1 or ord(sep)>=128 or sep in '0123456789'):\n    raise ValueError('Separator must be a single, non-numeric '+\n    'ASCII character')\n    \n   sep=sep.encode('ascii')\n   \n  self._sep=sep\n  \n @_takes_ascii\n def isoparse(self,dt_str):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  components,pos=self._parse_isodate(dt_str)\n  \n  if len(dt_str)>pos:\n   if self._sep is None or dt_str[pos:pos+1]==self._sep:\n    components +=self._parse_isotime(dt_str[pos+1:])\n   else :\n    raise ValueError('String contains unknown ISO components')\n    \n  if len(components)>3 and components[3]==24:\n   components[3]=0\n   return datetime(*components)+timedelta(days=1)\n   \n  return datetime(*components)\n  \n @_takes_ascii\n def parse_isodate(self,datestr):\n  ''\n\n\n\n\n\n\n\n  \n  components,pos=self._parse_isodate(datestr)\n  if pos <len(datestr):\n   raise ValueError('String contains unknown ISO '+\n   'components: {!r}'.format(datestr.decode('ascii')))\n  return date(*components)\n  \n @_takes_ascii\n def parse_isotime(self,timestr):\n  ''\n\n\n\n\n\n\n\n  \n  components=self._parse_isotime(timestr)\n  if components[0]==24:\n   components[0]=0\n  return time(*components)\n  \n @_takes_ascii\n def parse_tzstr(self,tzstr,zero_as_utc=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return self._parse_tzstr(tzstr,zero_as_utc=zero_as_utc)\n  \n  \n _DATE_SEP=b'-'\n _TIME_SEP=b':'\n _FRACTION_REGEX=re.compile(b'[\\\\.,]([0-9]+)')\n \n def _parse_isodate(self,dt_str):\n  try :\n   return self._parse_isodate_common(dt_str)\n  except ValueError:\n   return self._parse_isodate_uncommon(dt_str)\n   \n def _parse_isodate_common(self,dt_str):\n  len_str=len(dt_str)\n  components=[1,1,1]\n  \n  if len_str <4:\n   raise ValueError('ISO string too short')\n   \n   \n  components[0]=int(dt_str[0:4])\n  pos=4\n  if pos >=len_str:\n   return components,pos\n   \n  has_sep=dt_str[pos:pos+1]==self._DATE_SEP\n  if has_sep:\n   pos +=1\n   \n   \n  if len_str -pos <2:\n   raise ValueError('Invalid common month')\n   \n  components[1]=int(dt_str[pos:pos+2])\n  pos +=2\n  \n  if pos >=len_str:\n   if has_sep:\n    return components,pos\n   else :\n    raise ValueError('Invalid ISO format')\n    \n  if has_sep:\n   if dt_str[pos:pos+1]!=self._DATE_SEP:\n    raise ValueError('Invalid separator in ISO string')\n   pos +=1\n   \n   \n  if len_str -pos <2:\n   raise ValueError('Invalid common day')\n  components[2]=int(dt_str[pos:pos+2])\n  return components,pos+2\n  \n def _parse_isodate_uncommon(self,dt_str):\n  if len(dt_str)<4:\n   raise ValueError('ISO string too short')\n   \n   \n  year=int(dt_str[0:4])\n  \n  has_sep=dt_str[4:5]==self._DATE_SEP\n  \n  pos=4+has_sep\n  if dt_str[pos:pos+1]==b'W':\n  \n   pos +=1\n   weekno=int(dt_str[pos:pos+2])\n   pos +=2\n   \n   dayno=1\n   if len(dt_str)>pos:\n    if (dt_str[pos:pos+1]==self._DATE_SEP)!=has_sep:\n     raise ValueError('Inconsistent use of dash separator')\n     \n    pos +=has_sep\n    \n    dayno=int(dt_str[pos:pos+1])\n    pos +=1\n    \n   base_date=self._calculate_weekdate(year,weekno,dayno)\n  else :\n  \n   if len(dt_str)-pos <3:\n    raise ValueError('Invalid ordinal day')\n    \n   ordinal_day=int(dt_str[pos:pos+3])\n   pos +=3\n   \n   if ordinal_day <1 or ordinal_day >(365+calendar.isleap(year)):\n    raise ValueError('Invalid ordinal day'+\n    ' {} for year {}'.format(ordinal_day,year))\n    \n   base_date=date(year,1,1)+timedelta(days=ordinal_day -1)\n   \n  components=[base_date.year,base_date.month,base_date.day]\n  return components,pos\n  \n def _calculate_weekdate(self,year,week,day):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not 0 <week <54:\n   raise ValueError('Invalid week: {}'.format(week))\n   \n  if not 0 <day <8:\n   raise ValueError('Invalid weekday: {}'.format(day))\n   \n   \n  jan_4=date(year,1,4)\n  week_1=jan_4 -timedelta(days=jan_4.isocalendar()[2]-1)\n  \n  \n  week_offset=(week -1)*7+(day -1)\n  return week_1+timedelta(days=week_offset)\n  \n def _parse_isotime(self,timestr):\n  len_str=len(timestr)\n  components=[0,0,0,0,None ]\n  pos=0\n  comp=-1\n  \n  if len_str <2:\n   raise ValueError('ISO time too short')\n   \n  has_sep=False\n  \n  while pos <len_str and comp <5:\n   comp +=1\n   \n   if timestr[pos:pos+1]in b'-+Zz':\n   \n    components[-1]=self._parse_tzstr(timestr[pos:])\n    pos=len_str\n    break\n    \n   if comp ==1 and timestr[pos:pos+1]==self._TIME_SEP:\n    has_sep=True\n    pos +=1\n   elif comp ==2 and has_sep:\n    if timestr[pos:pos+1]!=self._TIME_SEP:\n     raise ValueError('Inconsistent use of colon separator')\n    pos +=1\n    \n   if comp <3:\n   \n    components[comp]=int(timestr[pos:pos+2])\n    pos +=2\n    \n   if comp ==3:\n   \n    frac=self._FRACTION_REGEX.match(timestr[pos:])\n    if not frac:\n     continue\n     \n    us_str=frac.group(1)[:6]\n    components[comp]=int(us_str)*10 **(6 -len(us_str))\n    pos +=len(frac.group())\n    \n  if pos <len_str:\n   raise ValueError('Unused components in ISO string')\n   \n  if components[0]==24:\n  \n   if any(component !=0 for component in components[1:4]):\n    raise ValueError('Hour may only be 24 at 24:00:00.000')\n    \n  return components\n  \n def _parse_tzstr(self,tzstr,zero_as_utc=True ):\n  if tzstr ==b'Z'or tzstr ==b'z':\n   return tz.UTC\n   \n  if len(tzstr)not in {3,5,6}:\n   raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')\n   \n  if tzstr[0:1]==b'-':\n   mult=-1\n  elif tzstr[0:1]==b'+':\n   mult=1\n  else :\n   raise ValueError('Time zone offset requires sign')\n   \n  hours=int(tzstr[1:3])\n  if len(tzstr)==3:\n   minutes=0\n  else :\n   minutes=int(tzstr[(4 if tzstr[3:4]==self._TIME_SEP else 3):])\n   \n  if zero_as_utc and hours ==0 and minutes ==0:\n   return tz.UTC\n  else :\n   if minutes >59:\n    raise ValueError('Invalid minutes in time zone offset')\n    \n   if hours >23:\n    raise ValueError('Invalid hours in time zone offset')\n    \n   return tz.tzoffset(None ,mult *(hours *60+minutes)*60)\n   \n   \nDEFAULT_ISOPARSER=isoparser()\nisoparse=DEFAULT_ISOPARSER.isoparse\n", ["calendar", "datetime", "dateutil", "functools", "re", "six"]], "dateutil.parser._parser": [".py", "\n''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import unicode_literals\n\nimport datetime\nimport re\nimport string\nimport time\nimport warnings\n\nfrom calendar import monthrange\nfrom io import StringIO\n\nimport six\nfrom six import integer_types,text_type\n\nfrom decimal import Decimal\n\nfrom warnings import warn\n\nfrom .. import relativedelta\nfrom .. import tz\n\n__all__=[\"parse\",\"parserinfo\",\"ParserError\"]\n\n\n\n\n\nclass _timelex(object):\n\n _split_decimal=re.compile(\"([.,])\")\n \n def __init__(self,instream):\n  if isinstance(instream,(bytes,bytearray)):\n   instream=instream.decode()\n   \n  if isinstance(instream,text_type):\n   instream=StringIO(instream)\n  elif getattr(instream,'read',None )is None :\n   raise TypeError('Parser must be a string or character stream, not '\n   '{itype}'.format(itype=instream.__class__.__name__))\n   \n  self.instream=instream\n  self.charstack=[]\n  self.tokenstack=[]\n  self.eof=False\n  \n def get_token(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.tokenstack:\n   return self.tokenstack.pop(0)\n   \n  seenletters=False\n  token=None\n  state=None\n  \n  while not self.eof:\n  \n  \n  \n  \n   if self.charstack:\n    nextchar=self.charstack.pop(0)\n   else :\n    nextchar=self.instream.read(1)\n    while nextchar =='\\x00':\n     nextchar=self.instream.read(1)\n     \n   if not nextchar:\n    self.eof=True\n    break\n   elif not state:\n   \n   \n    token=nextchar\n    if self.isword(nextchar):\n     state='a'\n    elif self.isnum(nextchar):\n     state='0'\n    elif self.isspace(nextchar):\n     token=' '\n     break\n    else :\n     break\n   elif state =='a':\n   \n   \n    seenletters=True\n    if self.isword(nextchar):\n     token +=nextchar\n    elif nextchar =='.':\n     token +=nextchar\n     state='a.'\n    else :\n     self.charstack.append(nextchar)\n     break\n   elif state =='0':\n   \n   \n    if self.isnum(nextchar):\n     token +=nextchar\n    elif nextchar =='.'or (nextchar ==','and len(token)>=2):\n     token +=nextchar\n     state='0.'\n    else :\n     self.charstack.append(nextchar)\n     break\n   elif state =='a.':\n   \n   \n    seenletters=True\n    if nextchar =='.'or self.isword(nextchar):\n     token +=nextchar\n    elif self.isnum(nextchar)and token[-1]=='.':\n     token +=nextchar\n     state='0.'\n    else :\n     self.charstack.append(nextchar)\n     break\n   elif state =='0.':\n   \n   \n    if nextchar =='.'or self.isnum(nextchar):\n     token +=nextchar\n    elif self.isword(nextchar)and token[-1]=='.':\n     token +=nextchar\n     state='a.'\n    else :\n     self.charstack.append(nextchar)\n     break\n     \n  if (state in ('a.','0.')and (seenletters or token.count('.')>1 or\n  token[-1]in '.,')):\n   l=self._split_decimal.split(token)\n   token=l[0]\n   for tok in l[1:]:\n    if tok:\n     self.tokenstack.append(tok)\n     \n  if state =='0.'and token.count('.')==0:\n   token=token.replace(',','.')\n   \n  return token\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  token=self.get_token()\n  if token is None :\n   raise StopIteration\n   \n  return token\n  \n def next(self):\n  return self.__next__()\n  \n @classmethod\n def split(cls,s):\n  return list(cls(s))\n  \n @classmethod\n def isword(cls,nextchar):\n  ''\n  return nextchar.isalpha()\n  \n @classmethod\n def isnum(cls,nextchar):\n  ''\n  return nextchar.isdigit()\n  \n @classmethod\n def isspace(cls,nextchar):\n  ''\n  return nextchar.isspace()\n  \n  \nclass _resultbase(object):\n\n def __init__(self):\n  for attr in self.__slots__:\n   setattr(self,attr,None )\n   \n def _repr(self,classname):\n  l=[]\n  for attr in self.__slots__:\n   value=getattr(self,attr)\n   if value is not None :\n    l.append(\"%s=%s\"%(attr,repr(value)))\n  return \"%s(%s)\"%(classname,\", \".join(l))\n  \n def __len__(self):\n  return (sum(getattr(self,attr)is not None\n  for attr in self.__slots__))\n  \n def __repr__(self):\n  return self._repr(self.__class__.__name__)\n  \n  \nclass parserinfo(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n JUMP=[\" \",\".\",\",\",\";\",\"-\",\"/\",\"'\",\n \"at\",\"on\",\"and\",\"ad\",\"m\",\"t\",\"of\",\n \"st\",\"nd\",\"rd\",\"th\"]\n \n WEEKDAYS=[(\"Mon\",\"Monday\"),\n (\"Tue\",\"Tuesday\"),\n (\"Wed\",\"Wednesday\"),\n (\"Thu\",\"Thursday\"),\n (\"Fri\",\"Friday\"),\n (\"Sat\",\"Saturday\"),\n (\"Sun\",\"Sunday\")]\n MONTHS=[(\"Jan\",\"January\"),\n (\"Feb\",\"February\"),\n (\"Mar\",\"March\"),\n (\"Apr\",\"April\"),\n (\"May\",\"May\"),\n (\"Jun\",\"June\"),\n (\"Jul\",\"July\"),\n (\"Aug\",\"August\"),\n (\"Sep\",\"Sept\",\"September\"),\n (\"Oct\",\"October\"),\n (\"Nov\",\"November\"),\n (\"Dec\",\"December\")]\n HMS=[(\"h\",\"hour\",\"hours\"),\n (\"m\",\"minute\",\"minutes\"),\n (\"s\",\"second\",\"seconds\")]\n AMPM=[(\"am\",\"a\"),\n (\"pm\",\"p\")]\n UTCZONE=[\"UTC\",\"GMT\",\"Z\",\"z\"]\n PERTAIN=[\"of\"]\n TZOFFSET={}\n \n \n \n def __init__(self,dayfirst=False ,yearfirst=False ):\n  self._jump=self._convert(self.JUMP)\n  self._weekdays=self._convert(self.WEEKDAYS)\n  self._months=self._convert(self.MONTHS)\n  self._hms=self._convert(self.HMS)\n  self._ampm=self._convert(self.AMPM)\n  self._utczone=self._convert(self.UTCZONE)\n  self._pertain=self._convert(self.PERTAIN)\n  \n  self.dayfirst=dayfirst\n  self.yearfirst=yearfirst\n  \n  self._year=time.localtime().tm_year\n  self._century=self._year //100 *100\n  \n def _convert(self,lst):\n  dct={}\n  for i,v in enumerate(lst):\n   if isinstance(v,tuple):\n    for v in v:\n     dct[v.lower()]=i\n   else :\n    dct[v.lower()]=i\n  return dct\n  \n def jump(self,name):\n  return name.lower()in self._jump\n  \n def weekday(self,name):\n  try :\n   return self._weekdays[name.lower()]\n  except KeyError:\n   pass\n  return None\n  \n def month(self,name):\n  try :\n   return self._months[name.lower()]+1\n  except KeyError:\n   pass\n  return None\n  \n def hms(self,name):\n  try :\n   return self._hms[name.lower()]\n  except KeyError:\n   return None\n   \n def ampm(self,name):\n  try :\n   return self._ampm[name.lower()]\n  except KeyError:\n   return None\n   \n def pertain(self,name):\n  return name.lower()in self._pertain\n  \n def utczone(self,name):\n  return name.lower()in self._utczone\n  \n def tzoffset(self,name):\n  if name in self._utczone:\n   return 0\n   \n  return self.TZOFFSET.get(name)\n  \n def convertyear(self,year,century_specified=False ):\n  ''\n\n\n  \n  \n  \n  assert year >=0\n  \n  if year <100 and not century_specified:\n  \n   year +=self._century\n   \n   if year >=self._year+50:\n    year -=100\n   elif year <self._year -50:\n    year +=100\n    \n  return year\n  \n def validate(self,res):\n \n  if res.year is not None :\n   res.year=self.convertyear(res.year,res.century_specified)\n   \n  if ((res.tzoffset ==0 and not res.tzname)or\n  (res.tzname =='Z'or res.tzname =='z')):\n   res.tzname=\"UTC\"\n   res.tzoffset=0\n  elif res.tzoffset !=0 and res.tzname and self.utczone(res.tzname):\n   res.tzoffset=0\n  return True\n  \n  \nclass _ymd(list):\n def __init__(self,*args,**kwargs):\n  super(self.__class__,self).__init__(*args,**kwargs)\n  self.century_specified=False\n  self.dstridx=None\n  self.mstridx=None\n  self.ystridx=None\n  \n @property\n def has_year(self):\n  return self.ystridx is not None\n  \n @property\n def has_month(self):\n  return self.mstridx is not None\n  \n @property\n def has_day(self):\n  return self.dstridx is not None\n  \n def could_be_day(self,value):\n  if self.has_day:\n   return False\n  elif not self.has_month:\n   return 1 <=value <=31\n  elif not self.has_year:\n  \n   month=self[self.mstridx]\n   return 1 <=value <=monthrange(2000,month)[1]\n  else :\n   month=self[self.mstridx]\n   year=self[self.ystridx]\n   return 1 <=value <=monthrange(year,month)[1]\n   \n def append(self,val,label=None ):\n  if hasattr(val,'__len__'):\n   if val.isdigit()and len(val)>2:\n    self.century_specified=True\n    if label not in [None ,'Y']:\n     raise ValueError(label)\n    label='Y'\n  elif val >100:\n   self.century_specified=True\n   if label not in [None ,'Y']:\n    raise ValueError(label)\n   label='Y'\n   \n  super(self.__class__,self).append(int(val))\n  \n  if label =='M':\n   if self.has_month:\n    raise ValueError('Month is already set')\n   self.mstridx=len(self)-1\n  elif label =='D':\n   if self.has_day:\n    raise ValueError('Day is already set')\n   self.dstridx=len(self)-1\n  elif label =='Y':\n   if self.has_year:\n    raise ValueError('Year is already set')\n   self.ystridx=len(self)-1\n   \n def _resolve_from_stridxs(self,strids):\n  ''\n\n\n  \n  if len(self)==3 and len(strids)==2:\n  \n   missing=[x for x in range(3)if x not in strids.values()]\n   key=[x for x in ['y','m','d']if x not in strids]\n   assert len(missing)==len(key)==1\n   key=key[0]\n   val=missing[0]\n   strids[key]=val\n   \n  assert len(self)==len(strids)\n  out={key:self[strids[key]]for key in strids}\n  return (out.get('y'),out.get('m'),out.get('d'))\n  \n def resolve_ymd(self,yearfirst,dayfirst):\n  len_ymd=len(self)\n  year,month,day=(None ,None ,None )\n  \n  strids=(('y',self.ystridx),\n  ('m',self.mstridx),\n  ('d',self.dstridx))\n  \n  strids={key:val for key,val in strids if val is not None }\n  if (len(self)==len(strids)>0 or\n  (len(self)==3 and len(strids)==2)):\n   return self._resolve_from_stridxs(strids)\n   \n  mstridx=self.mstridx\n  \n  if len_ymd >3:\n   raise ValueError(\"More than three YMD values\")\n  elif len_ymd ==1 or (mstridx is not None and len_ymd ==2):\n  \n   if mstridx is not None :\n    month=self[mstridx]\n    \n    \n    other=self[mstridx -1]\n   else :\n    other=self[0]\n    \n   if len_ymd >1 or mstridx is None :\n    if other >31:\n     year=other\n    else :\n     day=other\n     \n  elif len_ymd ==2:\n  \n   if self[0]>31:\n   \n    year,month=self\n   elif self[1]>31:\n   \n    month,year=self\n   elif dayfirst and self[1]<=12:\n   \n    day,month=self\n   else :\n   \n    month,day=self\n    \n  elif len_ymd ==3:\n  \n   if mstridx ==0:\n    if self[1]>31:\n    \n     month,year,day=self\n    else :\n     month,day,year=self\n   elif mstridx ==1:\n    if self[0]>31 or (yearfirst and self[2]<=31):\n    \n     year,month,day=self\n    else :\n    \n    \n    \n     day,month,year=self\n     \n   elif mstridx ==2:\n   \n    if self[1]>31:\n    \n     day,year,month=self\n    else :\n    \n     year,day,month=self\n     \n   else :\n    if (self[0]>31 or\n    self.ystridx ==0 or\n    (yearfirst and self[1]<=12 and self[2]<=31)):\n    \n     if dayfirst and self[2]<=12:\n      year,day,month=self\n     else :\n      year,month,day=self\n    elif self[0]>12 or (dayfirst and self[1]<=12):\n    \n     day,month,year=self\n    else :\n    \n     month,day,year=self\n     \n  return year,month,day\n  \n  \nclass parser(object):\n def __init__(self,info=None ):\n  self.info=info or parserinfo()\n  \n def parse(self,timestr,default=None ,\n ignoretz=False ,tzinfos=None ,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if default is None :\n   default=datetime.datetime.now().replace(hour=0,minute=0,\n   second=0,microsecond=0)\n   \n  res,skipped_tokens=self._parse(timestr,**kwargs)\n  \n  if res is None :\n   raise ParserError(\"Unknown string format: %s\",timestr)\n   \n  if len(res)==0:\n   raise ParserError(\"String does not contain a date: %s\",timestr)\n   \n  try :\n   ret=self._build_naive(res,default)\n  except ValueError as e:\n   six.raise_from(ParserError(str(e)+\": %s\",timestr),e)\n   \n  if not ignoretz:\n   ret=self._build_tzaware(ret,res,tzinfos)\n   \n  if kwargs.get('fuzzy_with_tokens',False ):\n   return ret,skipped_tokens\n  else :\n   return ret\n   \n class _result(_resultbase):\n  __slots__=[\"year\",\"month\",\"day\",\"weekday\",\n  \"hour\",\"minute\",\"second\",\"microsecond\",\n  \"tzname\",\"tzoffset\",\"ampm\",\"any_unused_tokens\"]\n  \n def _parse(self,timestr,dayfirst=None ,yearfirst=None ,fuzzy=False ,\n fuzzy_with_tokens=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if fuzzy_with_tokens:\n   fuzzy=True\n   \n  info=self.info\n  \n  if dayfirst is None :\n   dayfirst=info.dayfirst\n   \n  if yearfirst is None :\n   yearfirst=info.yearfirst\n   \n  res=self._result()\n  l=_timelex.split(timestr)\n  \n  skipped_idxs=[]\n  \n  \n  ymd=_ymd()\n  \n  len_l=len(l)\n  i=0\n  try :\n   while i <len_l:\n   \n   \n    value_repr=l[i]\n    try :\n     value=float(value_repr)\n    except ValueError:\n     value=None\n     \n    if value is not None :\n    \n     i=self._parse_numeric_token(l,i,info,ymd,res,fuzzy)\n     \n     \n    elif info.weekday(l[i])is not None :\n     value=info.weekday(l[i])\n     res.weekday=value\n     \n     \n    elif info.month(l[i])is not None :\n     value=info.month(l[i])\n     ymd.append(value,'M')\n     \n     if i+1 <len_l:\n      if l[i+1]in ('-','/'):\n      \n       sep=l[i+1]\n       ymd.append(l[i+2])\n       \n       if i+3 <len_l and l[i+3]==sep:\n       \n        ymd.append(l[i+4])\n        i +=2\n        \n       i +=2\n       \n      elif (i+4 <len_l and l[i+1]==l[i+3]==' 'and\n      info.pertain(l[i+2])):\n      \n      \n       if l[i+4].isdigit():\n       \n        value=int(l[i+4])\n        year=str(info.convertyear(value))\n        ymd.append(year,'Y')\n       else :\n       \n        pass\n        \n       i +=4\n       \n       \n    elif info.ampm(l[i])is not None :\n     value=info.ampm(l[i])\n     val_is_ampm=self._ampm_valid(res.hour,res.ampm,fuzzy)\n     \n     if val_is_ampm:\n      res.hour=self._adjust_ampm(res.hour,value)\n      res.ampm=value\n      \n     elif fuzzy:\n      skipped_idxs.append(i)\n      \n      \n    elif self._could_be_tzname(res.hour,res.tzname,res.tzoffset,l[i]):\n     res.tzname=l[i]\n     res.tzoffset=info.tzoffset(res.tzname)\n     \n     \n     \n     \n     \n     \n     if i+1 <len_l and l[i+1]in ('+','-'):\n      l[i+1]=('+','-')[l[i+1]=='+']\n      res.tzoffset=None\n      if info.utczone(res.tzname):\n      \n      \n       res.tzname=None\n       \n       \n    elif res.hour is not None and l[i]in ('+','-'):\n     signal=(-1,1)[l[i]=='+']\n     len_li=len(l[i+1])\n     \n     \n     if len_li ==4:\n     \n      hour_offset=int(l[i+1][:2])\n      min_offset=int(l[i+1][2:])\n     elif i+2 <len_l and l[i+2]==':':\n     \n      hour_offset=int(l[i+1])\n      min_offset=int(l[i+3])\n      i +=2\n     elif len_li <=2:\n     \n      hour_offset=int(l[i+1][:2])\n      min_offset=0\n     else :\n      raise ValueError(timestr)\n      \n     res.tzoffset=signal *(hour_offset *3600+min_offset *60)\n     \n     \n     if (i+5 <len_l and\n     info.jump(l[i+2])and l[i+3]=='('and\n     l[i+5]==')'and\n     3 <=len(l[i+4])and\n     self._could_be_tzname(res.hour,res.tzname,\n     None ,l[i+4])):\n     \n      res.tzname=l[i+4]\n      i +=4\n      \n     i +=1\n     \n     \n    elif not (info.jump(l[i])or fuzzy):\n     raise ValueError(timestr)\n     \n    else :\n     skipped_idxs.append(i)\n    i +=1\n    \n    \n   year,month,day=ymd.resolve_ymd(yearfirst,dayfirst)\n   \n   res.century_specified=ymd.century_specified\n   res.year=year\n   res.month=month\n   res.day=day\n   \n  except (IndexError,ValueError):\n   return None ,None\n   \n  if not info.validate(res):\n   return None ,None\n   \n  if fuzzy_with_tokens:\n   skipped_tokens=self._recombine_skipped(l,skipped_idxs)\n   return res,tuple(skipped_tokens)\n  else :\n   return res,None\n   \n def _parse_numeric_token(self,tokens,idx,info,ymd,res,fuzzy):\n \n  value_repr=tokens[idx]\n  try :\n   value=self._to_decimal(value_repr)\n  except Exception as e:\n   six.raise_from(ValueError('Unknown numeric token'),e)\n   \n  len_li=len(value_repr)\n  \n  len_l=len(tokens)\n  \n  if (len(ymd)==3 and len_li in (2,4)and\n  res.hour is None and\n  (idx+1 >=len_l or\n  (tokens[idx+1]!=':'and\n  info.hms(tokens[idx+1])is None ))):\n  \n   s=tokens[idx]\n   res.hour=int(s[:2])\n   \n   if len_li ==4:\n    res.minute=int(s[2:])\n    \n  elif len_li ==6 or (len_li >6 and tokens[idx].find('.')==6):\n  \n   s=tokens[idx]\n   \n   if not ymd and '.'not in tokens[idx]:\n    ymd.append(s[:2])\n    ymd.append(s[2:4])\n    ymd.append(s[4:])\n   else :\n   \n   \n   \n    res.hour=int(s[:2])\n    res.minute=int(s[2:4])\n    res.second,res.microsecond=self._parsems(s[4:])\n    \n  elif len_li in (8,12,14):\n  \n   s=tokens[idx]\n   ymd.append(s[:4],'Y')\n   ymd.append(s[4:6])\n   ymd.append(s[6:8])\n   \n   if len_li >8:\n    res.hour=int(s[8:10])\n    res.minute=int(s[10:12])\n    \n    if len_li >12:\n     res.second=int(s[12:])\n     \n  elif self._find_hms_idx(idx,tokens,info,allow_jump=True )is not None :\n  \n   hms_idx=self._find_hms_idx(idx,tokens,info,allow_jump=True )\n   (idx,hms)=self._parse_hms(idx,tokens,info,hms_idx)\n   if hms is not None :\n   \n   \n    self._assign_hms(res,value_repr,hms)\n    \n  elif idx+2 <len_l and tokens[idx+1]==':':\n  \n   res.hour=int(value)\n   value=self._to_decimal(tokens[idx+2])\n   (res.minute,res.second)=self._parse_min_sec(value)\n   \n   if idx+4 <len_l and tokens[idx+3]==':':\n    res.second,res.microsecond=self._parsems(tokens[idx+4])\n    \n    idx +=2\n    \n   idx +=2\n   \n  elif idx+1 <len_l and tokens[idx+1]in ('-','/','.'):\n   sep=tokens[idx+1]\n   ymd.append(value_repr)\n   \n   if idx+2 <len_l and not info.jump(tokens[idx+2]):\n    if tokens[idx+2].isdigit():\n    \n     ymd.append(tokens[idx+2])\n    else :\n    \n     value=info.month(tokens[idx+2])\n     \n     if value is not None :\n      ymd.append(value,'M')\n     else :\n      raise ValueError()\n      \n    if idx+3 <len_l and tokens[idx+3]==sep:\n    \n     value=info.month(tokens[idx+4])\n     \n     if value is not None :\n      ymd.append(value,'M')\n     else :\n      ymd.append(tokens[idx+4])\n     idx +=2\n     \n    idx +=1\n   idx +=1\n   \n  elif idx+1 >=len_l or info.jump(tokens[idx+1]):\n   if idx+2 <len_l and info.ampm(tokens[idx+2])is not None :\n   \n    hour=int(value)\n    res.hour=self._adjust_ampm(hour,info.ampm(tokens[idx+2]))\n    idx +=1\n   else :\n   \n    ymd.append(value)\n   idx +=1\n   \n  elif info.ampm(tokens[idx+1])is not None and (0 <=value <24):\n  \n   hour=int(value)\n   res.hour=self._adjust_ampm(hour,info.ampm(tokens[idx+1]))\n   idx +=1\n   \n  elif ymd.could_be_day(value):\n   ymd.append(value)\n   \n  elif not fuzzy:\n   raise ValueError()\n   \n  return idx\n  \n def _find_hms_idx(self,idx,tokens,info,allow_jump):\n  len_l=len(tokens)\n  \n  if idx+1 <len_l and info.hms(tokens[idx+1])is not None :\n  \n  \n  \n   hms_idx=idx+1\n   \n  elif (allow_jump and idx+2 <len_l and tokens[idx+1]==' 'and\n  info.hms(tokens[idx+2])is not None ):\n  \n  \n   hms_idx=idx+2\n   \n  elif idx >0 and info.hms(tokens[idx -1])is not None :\n  \n  \n  \n  \n   hms_idx=idx -1\n   \n  elif (1 <idx ==len_l -1 and tokens[idx -1]==' 'and\n  info.hms(tokens[idx -2])is not None ):\n  \n  \n  \n   hms_idx=idx -2\n   \n  else :\n   hms_idx=None\n   \n  return hms_idx\n  \n def _assign_hms(self,res,value_repr,hms):\n \n  value=self._to_decimal(value_repr)\n  \n  if hms ==0:\n  \n   res.hour=int(value)\n   if value %1:\n    res.minute=int(60 *(value %1))\n    \n  elif hms ==1:\n   (res.minute,res.second)=self._parse_min_sec(value)\n   \n  elif hms ==2:\n   (res.second,res.microsecond)=self._parsems(value_repr)\n   \n def _could_be_tzname(self,hour,tzname,tzoffset,token):\n  return (hour is not None and\n  tzname is None and\n  tzoffset is None and\n  len(token)<=5 and\n  (all(x in string.ascii_uppercase for x in token)\n  or token in self.info.UTCZONE))\n  \n def _ampm_valid(self,hour,ampm,fuzzy):\n  ''\n\n\n\n  \n  val_is_ampm=True\n  \n  \n  if fuzzy and ampm is not None :\n   val_is_ampm=False\n   \n   \n  if hour is None :\n   if fuzzy:\n    val_is_ampm=False\n   else :\n    raise ValueError('No hour specified with AM or PM flag.')\n  elif not 0 <=hour <=12:\n  \n  \n   if fuzzy:\n    val_is_ampm=False\n   else :\n    raise ValueError('Invalid hour specified for 12-hour clock.')\n    \n  return val_is_ampm\n  \n def _adjust_ampm(self,hour,ampm):\n  if hour <12 and ampm ==1:\n   hour +=12\n  elif hour ==12 and ampm ==0:\n   hour=0\n  return hour\n  \n def _parse_min_sec(self,value):\n \n \n \n  minute=int(value)\n  second=None\n  \n  sec_remainder=value %1\n  if sec_remainder:\n   second=int(60 *sec_remainder)\n  return (minute,second)\n  \n def _parse_hms(self,idx,tokens,info,hms_idx):\n \n \n \n \n  if hms_idx is None :\n   hms=None\n   new_idx=idx\n  elif hms_idx >idx:\n   hms=info.hms(tokens[hms_idx])\n   new_idx=hms_idx\n  else :\n  \n   hms=info.hms(tokens[hms_idx])+1\n   new_idx=idx\n   \n  return (new_idx,hms)\n  \n  \n  \n  \n  \n def _parsems(self,value):\n  ''\n  if \".\"not in value:\n   return int(value),0\n  else :\n   i,f=value.split(\".\")\n   return int(i),int(f.ljust(6,\"0\")[:6])\n   \n def _to_decimal(self,val):\n  try :\n   decimal_value=Decimal(val)\n   \n   \n   if not decimal_value.is_finite():\n    raise ValueError(\"Converted decimal value is infinite or NaN\")\n  except Exception as e:\n   msg=\"Could not convert %s to decimal\"%val\n   six.raise_from(ValueError(msg),e)\n  else :\n   return decimal_value\n   \n   \n   \n   \n   \n   \n def _build_tzinfo(self,tzinfos,tzname,tzoffset):\n  if callable(tzinfos):\n   tzdata=tzinfos(tzname,tzoffset)\n  else :\n   tzdata=tzinfos.get(tzname)\n   \n   \n  if isinstance(tzdata,datetime.tzinfo)or tzdata is None :\n   tzinfo=tzdata\n  elif isinstance(tzdata,text_type):\n   tzinfo=tz.tzstr(tzdata)\n  elif isinstance(tzdata,integer_types):\n   tzinfo=tz.tzoffset(tzname,tzdata)\n  else :\n   raise TypeError(\"Offset must be tzinfo subclass, tz string, \"\n   \"or int offset.\")\n  return tzinfo\n  \n def _build_tzaware(self,naive,res,tzinfos):\n  if (callable(tzinfos)or (tzinfos and res.tzname in tzinfos)):\n   tzinfo=self._build_tzinfo(tzinfos,res.tzname,res.tzoffset)\n   aware=naive.replace(tzinfo=tzinfo)\n   aware=self._assign_tzname(aware,res.tzname)\n   \n  elif res.tzname and res.tzname in time.tzname:\n   aware=naive.replace(tzinfo=tz.tzlocal())\n   \n   \n   aware=self._assign_tzname(aware,res.tzname)\n   \n   \n   if (aware.tzname()!=res.tzname and\n   res.tzname in self.info.UTCZONE):\n    aware=aware.replace(tzinfo=tz.UTC)\n    \n  elif res.tzoffset ==0:\n   aware=naive.replace(tzinfo=tz.UTC)\n   \n  elif res.tzoffset:\n   aware=naive.replace(tzinfo=tz.tzoffset(res.tzname,res.tzoffset))\n   \n  elif not res.tzname and not res.tzoffset:\n  \n   aware=naive\n   \n  elif res.tzname:\n  \n  \n   warnings.warn(\"tzname {tzname} identified but not understood.  \"\n   \"Pass `tzinfos` argument in order to correctly \"\n   \"return a timezone-aware datetime.  In a future \"\n   \"version, this will raise an \"\n   \"exception.\".format(tzname=res.tzname),\n   category=UnknownTimezoneWarning)\n   aware=naive\n   \n  return aware\n  \n def _build_naive(self,res,default):\n  repl={}\n  for attr in (\"year\",\"month\",\"day\",\"hour\",\n  \"minute\",\"second\",\"microsecond\"):\n   value=getattr(res,attr)\n   if value is not None :\n    repl[attr]=value\n    \n  if 'day'not in repl:\n  \n  \n   cyear=default.year if res.year is None else res.year\n   cmonth=default.month if res.month is None else res.month\n   cday=default.day if res.day is None else res.day\n   \n   if cday >monthrange(cyear,cmonth)[1]:\n    repl['day']=monthrange(cyear,cmonth)[1]\n    \n  naive=default.replace(**repl)\n  \n  if res.weekday is not None and not res.day:\n   naive=naive+relativedelta.relativedelta(weekday=res.weekday)\n   \n  return naive\n  \n def _assign_tzname(self,dt,tzname):\n  if dt.tzname()!=tzname:\n   new_dt=tz.enfold(dt,fold=1)\n   if new_dt.tzname()==tzname:\n    return new_dt\n    \n  return dt\n  \n def _recombine_skipped(self,tokens,skipped_idxs):\n  ''\n\n\n\n\n  \n  skipped_tokens=[]\n  for i,idx in enumerate(sorted(skipped_idxs)):\n   if i >0 and idx -1 ==skipped_idxs[i -1]:\n    skipped_tokens[-1]=skipped_tokens[-1]+tokens[idx]\n   else :\n    skipped_tokens.append(tokens[idx])\n    \n  return skipped_tokens\n  \n  \nDEFAULTPARSER=parser()\n\n\ndef parse(timestr,parserinfo=None ,**kwargs):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if parserinfo:\n  return parser(parserinfo).parse(timestr,**kwargs)\n else :\n  return DEFAULTPARSER.parse(timestr,**kwargs)\n  \n  \nclass _tzparser(object):\n\n class _result(_resultbase):\n \n  __slots__=[\"stdabbr\",\"stdoffset\",\"dstabbr\",\"dstoffset\",\n  \"start\",\"end\"]\n  \n  class _attr(_resultbase):\n   __slots__=[\"month\",\"week\",\"weekday\",\n   \"yday\",\"jyday\",\"day\",\"time\"]\n   \n  def __repr__(self):\n   return self._repr(\"\")\n   \n  def __init__(self):\n   _resultbase.__init__(self)\n   self.start=self._attr()\n   self.end=self._attr()\n   \n def parse(self,tzstr):\n  res=self._result()\n  l=[x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr)if x]\n  used_idxs=list()\n  try :\n  \n   len_l=len(l)\n   \n   i=0\n   while i <len_l:\n   \n    j=i\n    while j <len_l and not [x for x in l[j]\n    if x in \"0123456789:,-+\"]:\n     j +=1\n    if j !=i:\n     if not res.stdabbr:\n      offattr=\"stdoffset\"\n      res.stdabbr=\"\".join(l[i:j])\n     else :\n      offattr=\"dstoffset\"\n      res.dstabbr=\"\".join(l[i:j])\n      \n     for ii in range(j):\n      used_idxs.append(ii)\n     i=j\n     if (i <len_l and (l[i]in ('+','-')or l[i][0]in\n     \"0123456789\")):\n      if l[i]in ('+','-'):\n      \n      \n       signal=(1,-1)[l[i]=='+']\n       used_idxs.append(i)\n       i +=1\n      else :\n       signal=-1\n      len_li=len(l[i])\n      if len_li ==4:\n      \n       setattr(res,offattr,(int(l[i][:2])*3600+\n       int(l[i][2:])*60)*signal)\n      elif i+1 <len_l and l[i+1]==':':\n      \n       setattr(res,offattr,\n       (int(l[i])*3600+\n       int(l[i+2])*60)*signal)\n       used_idxs.append(i)\n       i +=2\n      elif len_li <=2:\n      \n       setattr(res,offattr,\n       int(l[i][:2])*3600 *signal)\n      else :\n       return None\n      used_idxs.append(i)\n      i +=1\n     if res.dstabbr:\n      break\n    else :\n     break\n     \n     \n   if i <len_l:\n    for j in range(i,len_l):\n     if l[j]==';':\n      l[j]=','\n      \n    assert l[i]==','\n    \n    i +=1\n    \n   if i >=len_l:\n    pass\n   elif (8 <=l.count(',')<=9 and\n   not [y for x in l[i:]if x !=','\n   for y in x if y not in \"0123456789+-\"]):\n   \n    for x in (res.start,res.end):\n     x.month=int(l[i])\n     used_idxs.append(i)\n     i +=2\n     if l[i]=='-':\n      value=int(l[i+1])*-1\n      used_idxs.append(i)\n      i +=1\n     else :\n      value=int(l[i])\n     used_idxs.append(i)\n     i +=2\n     if value:\n      x.week=value\n      x.weekday=(int(l[i])-1)%7\n     else :\n      x.day=int(l[i])\n     used_idxs.append(i)\n     i +=2\n     x.time=int(l[i])\n     used_idxs.append(i)\n     i +=2\n    if i <len_l:\n     if l[i]in ('-','+'):\n      signal=(-1,1)[l[i]==\"+\"]\n      used_idxs.append(i)\n      i +=1\n     else :\n      signal=1\n     used_idxs.append(i)\n     res.dstoffset=(res.stdoffset+int(l[i])*signal)\n     \n     \n    warn(('Parsed time zone \"%s\"'%tzstr)+\n    'is in a non-standard dateutil-specific format, which '+\n    'is now deprecated; support for parsing this format '+\n    'will be removed in future versions. It is recommended '+\n    'that you switch to a standard format like the GNU '+\n    'TZ variable format.',tz.DeprecatedTzFormatWarning)\n   elif (l.count(',')==2 and l[i:].count('/')<=2 and\n   not [y for x in l[i:]if x not in (',','/','J','M',\n   '.','-',':')\n   for y in x if y not in \"0123456789\"]):\n    for x in (res.start,res.end):\n     if l[i]=='J':\n     \n      used_idxs.append(i)\n      i +=1\n      x.jyday=int(l[i])\n     elif l[i]=='M':\n     \n      used_idxs.append(i)\n      i +=1\n      x.month=int(l[i])\n      used_idxs.append(i)\n      i +=1\n      assert l[i]in ('-','.')\n      used_idxs.append(i)\n      i +=1\n      x.week=int(l[i])\n      if x.week ==5:\n       x.week=-1\n      used_idxs.append(i)\n      i +=1\n      assert l[i]in ('-','.')\n      used_idxs.append(i)\n      i +=1\n      x.weekday=(int(l[i])-1)%7\n     else :\n     \n      x.yday=int(l[i])+1\n      \n     used_idxs.append(i)\n     i +=1\n     \n     if i <len_l and l[i]=='/':\n      used_idxs.append(i)\n      i +=1\n      \n      len_li=len(l[i])\n      if len_li ==4:\n      \n       x.time=(int(l[i][:2])*3600+\n       int(l[i][2:])*60)\n      elif i+1 <len_l and l[i+1]==':':\n      \n       x.time=int(l[i])*3600+int(l[i+2])*60\n       used_idxs.append(i)\n       i +=2\n       if i+1 <len_l and l[i+1]==':':\n        used_idxs.append(i)\n        i +=2\n        x.time +=int(l[i])\n      elif len_li <=2:\n      \n       x.time=(int(l[i][:2])*3600)\n      else :\n       return None\n      used_idxs.append(i)\n      i +=1\n      \n     assert i ==len_l or l[i]==','\n     \n     i +=1\n     \n    assert i >=len_l\n    \n  except (IndexError,ValueError,AssertionError):\n   return None\n   \n  unused_idxs=set(range(len_l)).difference(used_idxs)\n  res.any_unused_tokens=not {l[n]for n in unused_idxs}.issubset({\",\",\":\"})\n  return res\n  \n  \nDEFAULTTZPARSER=_tzparser()\n\n\ndef _parsetz(tzstr):\n return DEFAULTTZPARSER.parse(tzstr)\n \n \nclass ParserError(ValueError):\n ''\n\n\n\n\n\n \n def __str__(self):\n  try :\n   return self.args[0]%self.args[1:]\n  except (TypeError,IndexError):\n   return super(ParserError,self).__str__()\n   \n def __repr__(self):\n  args=\", \".join(\"'%s'\"%arg for arg in self.args)\n  return \"%s(%s)\"%(self.__class__.__name__,args)\n  \n  \nclass UnknownTimezoneWarning(RuntimeWarning):\n ''\n\n\n \n \n", ["__future__", "calendar", "datetime", "dateutil", "dateutil.relativedelta", "decimal", "io", "re", "six", "string", "time", "warnings"]], "dateutil.parser": [".py", "\nfrom ._parser import parse,parser,parserinfo,ParserError\nfrom ._parser import DEFAULTPARSER,DEFAULTTZPARSER\nfrom ._parser import UnknownTimezoneWarning\n\nfrom ._parser import __doc__\n\nfrom .isoparser import isoparser,isoparse\n\n__all__=['parse','parser','parserinfo',\n'isoparse','isoparser',\n'ParserError',\n'UnknownTimezoneWarning']\n\n\n\n\n\n\n\ndef __deprecated_private_func(f):\n from functools import wraps\n import warnings\n \n msg=('{name} is a private function and may break without warning, '\n 'it will be moved and or renamed in future versions.')\n msg=msg.format(name=f.__name__)\n \n @wraps(f)\n def deprecated_func(*args,**kwargs):\n  warnings.warn(msg,DeprecationWarning)\n  return f(*args,**kwargs)\n  \n return deprecated_func\n \ndef __deprecate_private_class(c):\n import warnings\n \n msg=('{name} is a private class and may break without warning, '\n 'it will be moved and or renamed in future versions.')\n msg=msg.format(name=c.__name__)\n \n class private_class(c):\n  __doc__=c.__doc__\n  \n  def __init__(self,*args,**kwargs):\n   warnings.warn(msg,DeprecationWarning)\n   super(private_class,self).__init__(*args,**kwargs)\n   \n private_class.__name__=c.__name__\n \n return private_class\n \n \nfrom ._parser import _timelex,_resultbase\nfrom ._parser import _tzparser,_parsetz\n\n_timelex=__deprecate_private_class(_timelex)\n_tzparser=__deprecate_private_class(_tzparser)\n_resultbase=__deprecate_private_class(_resultbase)\n_parsetz=__deprecated_private_func(_parsetz)\n", ["dateutil.parser._parser", "dateutil.parser.isoparser", "functools", "warnings"], 1], "charts.css": [".py", "\n\n\n__version__=\"0.4.0\"\n\n\ndef transpose(matrix):\n ''\n\n\n\n\n\n \n return list(zip(*matrix))\n \n \nclass Legend:\n _shape=\"\"\n def __init__(self,legends:list,inline=None ):\n  self._legends=legends\n  self._inline=inline\n def __str__(self):\n  return \"<ul class='charts-css legend {} {}'>{}</ul>\".format(\n  self._shape,\n  \"legend-inline\"if self._inline else \"\",\n  \"\".join(\"<li>{}</li>\".format(legend)for legend in self._legends))\n  \nclass LegendCircle(Legend):\n _shape=\"legend-circle\"\n \nclass LegendEllipse(Legend):\n _shape=\"legend-ellipse\"\n \nclass LegendSquare(Legend):\n _shape=\"legend-square\"\n \nclass LegendRectangle(Legend):\n _shape=\"legend-rectangle\"\n \nclass LegendRhombus(Legend):\n _shape=\"legend-rhombus\"\n \nclass LegendLine(Legend):\n _shape=\"legend-line\"\n \nSHOW_SECONDARY_AXES=range(11)\nDATA_SPACING=range(21)\nDATASETS_SPACING=range(21)\n\ndef _chart(\nrows:list,\n_type,\n*,\nheaders_in_first_row=False ,\nheaders_in_first_column=False ,\nlegend=None ,\nlegend_inline=False ,\n\n_series_upper_bound=None ,\n\nvalue_displayer=None ,\nvalue_converter=None ,\nstacked=False ,\n\nheading:str=None ,\nhide_label=None ,\nhide_data=False ,\nshow_data_on_hover=False ,\nreverse=False ,\n\n\nreverse_data=False ,\nreverse_datasets=False ,\n\n\nshow_data_axes=False ,\nshow_secondary_axes=None ,\n\n\ndata_spacing=None ,\ndatasets_spacing=None ,\n\ntooltip_builder=None ,\n\n\n\n)->str:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n assert rows\n if not (rows and len(rows)>(1 if headers_in_first_row else 0)):\n  raise ValueError(\"rows (excluding header row) needs to contain numeric content.\")\n if show_secondary_axes and show_secondary_axes not in SHOW_SECONDARY_AXES:\n  raise ValueError(\n  \"show_secondary_axes should range in {}\".format(SHOW_SECONDARY_AXES))\n if data_spacing and data_spacing not in DATA_SPACING:\n  raise ValueError(\n  \"data_spacing should range in {}\".format(DATA_SPACING))\n if datasets_spacing and datasets_spacing not in DATASETS_SPACING:\n  raise ValueError(\n  \"datasets_spacing should range in {}\".format(DATASETS_SPACING))\n  \n classes=list(filter(None ,[\n \"charts-css\",\n _type,\n \"show-labels\",\n \"show-heading\"if heading else None ,\n hide_data and \"hide-data\",\n \"show-data-on-hover\"if show_data_on_hover else None ,\n \"reverse\"if reverse else None ,\n \"show-primary-axis\",\n \"show-data-axes\"if show_data_axes else None ,\n \n \"show-{}-secondary-axes\".format(show_secondary_axes)if show_secondary_axes else None ,\n \"data-spacing-{}\".format(data_spacing)if data_spacing else None ,\n \"datasets-spacing-{}\".format(datasets_spacing)if datasets_spacing else None ,\n \"reverse-data\"if reverse_data else None ,\n \"reverse-datasets\"if reverse_datasets else None ,\n \"stacked\"if stacked else None ,\n ]))\n \n def as_is(raw):\n  return raw\n  \n def cell2dict(raw):\n  return raw if isinstance(raw,dict)else {\"value\":raw}\n normalized_rows=[list(\n map(cell2dict,row)\n )for row in rows]\n padding=0.2 if _type ==\"line\"else 0\n \n def numeric_values_in_a_row(row,value_converter=value_converter,as_is=as_is):\n  _data_starts_at_row=(\n  \n  1 if headers_in_first_column else 0)\n  values=[\n  (value_converter or as_is)(cell[\"value\"])\n  for cell in row[_data_starts_at_row:]]\n  if not values:\n   raise ValueError(\"Inputed rows should contain at least one numeric column\")\n  for v in values:\n   if not isinstance(v,(int,float)):\n    raise ValueError(\n    \"Cell ({}) needs to be either a numeric value, \"\n    \"or converted to a numeric value by value_converter, \"\n    \"or declared as a row/column header.\".format(repr(v)))\n  return values\n  \n first_data_row=1 if headers_in_first_row else 0\n if len(numeric_values_in_a_row(normalized_rows[first_data_row]))>1:\n  classes.append(\"multiple\")\n  \n global_upper_bound=max(\n (sum if stacked else max)(numeric_values_in_a_row(row))\n for row in normalized_rows[first_data_row:]\n )+padding\n \n \n table_rows=[]\n previous_row=None\n for y,row in enumerate(normalized_rows[first_data_row:]):\n  denominator=_series_upper_bound(\n  numeric_values_in_a_row(row)\n  )if _series_upper_bound else global_upper_bound\n  \n  cells=[(\n  \"\"\"      <th scope=\"row\"{classes}>{value}</th>\"\"\".format(\n  value=cell[\"value\"],\n  classes=' class=\"hide-label\"'\n  if hide_label and hide_label(y,cell[\"value\"])else \"\",\n  )\n  if x ==0 and headers_in_first_column else\n  \"\"\"      <td style=\"{start}--size:calc({value}/{denominator});\">\n        <span class=\"data\">{data}</span> {tooltip}\n      </td>\"\"\".format(\n  start=\"--start:calc({value}/{denominator});\".format(\n  value=previous_row[x][\"value\"]if previous_row else cell[\"value\"],\n  denominator=denominator,\n  )if _type in (\"line\",\"area\")else \"\",\n  value=cell[\"value\"],\n  denominator=denominator,\n  data=cell.get(\"data\",(value_displayer or as_is)(cell[\"value\"])),\n  tooltip=_get_tooltip(cell,x,y,row,tooltip_builder),\n  )\n  )for x,cell in enumerate(row)]\n  table_rows.append(\"    <tr>\\n{}\\n    </tr>\".format(\"\\n\".join(cells)))\n  previous_row=row\n  \n table=\"\"\"<table class='{classes}'>\n  {heading}\n{thead}\n  <tbody>\n{rows}\n  </tbody>\n</table>\n\"\"\".format(\n classes=\" \".join(classes),\n heading=\"<caption>{}</caption>\".format(heading)if heading else \"\",\n thead=\"\"\"  <thead>\n    <tr>\n      {}\n    </tr>\n  </thead>\"\"\".format(\n \"\\n      \".join('<th scope=\"col\">{}</th>'.format(h)for h in rows[0])\n )if headers_in_first_row else \"\",\n rows=\"\\n\".join(table_rows),\n )\n return \"{table}{legend}\".format(\n table=table,\n legend=legend(rows[0][first_data_row:],inline=legend_inline),\n )if legend and headers_in_first_row else table\n \ndef _get_tooltip(cell,column_number,row_number,row,tooltip_builder):\n assert isinstance(cell,dict),\"cell should have been normalized into a dict\"\n template='<span class=\"tooltip\">{}</span>'\n if \"tooltip\"in cell:\n  return template.format(cell[\"tooltip\"])\n if tooltip_builder:\n  return template.format(tooltip_builder(\n  value=cell[\"value\"],\n  label=row[0][\"value\"],\n  column_number=column_number,\n  row_number=row_number,\n  row=row,\n  ))\n return \"\"\n \n \ndef bar(rows,*,stacked=False ,percentage=False ,**kwargs)->str:\n return _chart(\n rows,\n \"bar\",stacked=stacked,_series_upper_bound=sum if percentage else None ,\n **kwargs)\n \ndef column(rows,*,stacked=False ,percentage=False ,**kwargs)->str:\n return _chart(\n rows,\n \"column\",stacked=stacked,_series_upper_bound=sum if percentage else None ,\n **kwargs)\n \ndef area(rows,**kwargs)->str:\n return _chart(rows,\"area\",**kwargs)\n \ndef line(rows,data_spacing=None ,datasets_spacing=None ,**kwargs)->str:\n if data_spacing or datasets_spacing:\n  raise ValueError(\"data_spacing or datasets_spacing would break line into segments\")\n return _chart(rows,\"line\",**kwargs)\n \n \nLAYOUT=\"\"\"\n#${wrapper_id} {\n  display: grid;\n  align-items: center;\n  justify-items: center;\n  background-color: #eee;\n\n  height: calc(100vh - 1em);\n  grid-template-areas:\n    \"header header header\"\n    \"sidebar_left loft sidebar_right\"\n    \"sidebar_left main sidebar_right\"\n    \"sidebar_left basement sidebar_right\"\n    \"footer footer footer\";\n  grid-template-columns: auto 1fr auto;\n  grid-template-rows: auto auto 1fr auto auto;\n}\n\"\"\"\n\nARRANGEMENT=\"\"\"\ntable.charts-css {grid-area: main;}\nul.charts-css.legend {\n  grid-area: sidebar_right;\n}\n\"\"\"\n\n\ndef wrapper(*charts,wrapper_id=None ,layout=None ,arrangement=None ):\n import string\n wrapper_id=wrapper_id or \"my_chart\"\n return \"\"\"<style>{layout}{arrangement}</style>\n<div id=\"{wrapper_id}\">\n{charts}\n</div>\n\"\"\".format(\n wrapper_id=wrapper_id,\n charts=\"\\n\".join(charts),\n layout=string.Template(layout or LAYOUT).safe_substitute(wrapper_id=wrapper_id),\n arrangement=string.Template(arrangement or ARRANGEMENT).safe_substitute(wrapper_id=wrapper_id),\n )\n \nSTYLESHEET='<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/charts.css/dist/charts.min.css\">'\n", ["string"]], "charts": [".py", "", [], 1]}
__BRYTHON__.update_VFS(scripts)
